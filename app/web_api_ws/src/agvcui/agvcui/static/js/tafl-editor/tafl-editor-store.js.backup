/**
 * TAFL Editor Store - åŸºæ–¼ miniStore çš„ç‹€æ…‹ç®¡ç†
 * ç®¡ç† TAFL Editor çš„æ‰€æœ‰ç‹€æ…‹å’Œäº‹ä»¶
 */

import { createStore } from '../../store/miniStore.js';
import taflDebug from './tafl-debug.js';
import taflEventBus from './tafl-event-bus.js';

class TAFLFlowStore {
    constructor() {
        // Add unique identifier to track store instance
        this.storeId = `store_${Date.now()}_${Math.random()}`;
        console.log(`ğŸ—ï¸ TAFLFlowStore constructor called, instance ID: ${this.storeId}`);
        
        // TAFL v1.1 é è¨­æµç¨‹çµæ§‹
        const defaultFlow = {
            metadata: {
                id: null,
                name: 'Untitled Flow',
                version: '1.1',
                description: ''
            },
            settings: {
                timeout: 3600,
                max_retries: 3,
                retry_on_failure: false
            },
            preload: {},
            rules: {},
            variables: {},
            flow: []
        };
        
        // å‰µå»ºåº•å±¤ miniStore
        this.baseStore = createStore('taflEditor', {
            currentFlow: defaultFlow,
            selectedCardId: null,
            isDirty: false,
            lastSaved: null,
            verbDefinitions: {},
            cardCounter: 0
        });
        
        // Fix cardCounter and reset flow after loading from localStorage
        const state = this.baseStore.getState();
        let updatedState = { ...state };
        
        // Fix cardCounter if invalid
        if (typeof state.cardCounter !== 'number' || isNaN(state.cardCounter)) {
            updatedState.cardCounter = 0;
        }
        
        // Validate and clean up flow.flow array
        if (state.currentFlow && state.currentFlow.flow) {
            console.log('ğŸ§™ Validating loaded flow:', state.currentFlow.flow);
            // Filter out invalid cards (cards without any verb)
            const validFlow = state.currentFlow.flow.filter(card => {
                if (!card || typeof card !== 'object') return false;
                // Check if card has at least one valid verb key
                const hasVerb = Object.keys(card).some(key => 
                    key !== 'id' && key !== 'comment' && key !== '_id'
                );
                if (!hasVerb) {
                    console.warn('ğŸ§™ Removing invalid card from flow:', card);
                }
                return hasVerb;
            });
            
            if (validFlow.length !== state.currentFlow.flow.length) {
                console.log(`ğŸ§™ Cleaned flow: removed ${state.currentFlow.flow.length - validFlow.length} invalid cards`);
                updatedState.currentFlow = {
                    ...state.currentFlow,
                    flow: validFlow
                };
                this.baseStore.setState(updatedState);
            }
        }
        
        // DON'T auto-load old flow on initialization - comment out to preserve loaded flows
        // If you want to always start with an empty flow, uncomment these lines:
        // updatedState.currentFlow = defaultFlow;
        // updatedState.selectedCardId = null;
        // updatedState.isDirty = false;
        // this.baseStore.setState(updatedState);
        
        // é¡å¤–çš„äº‹ä»¶ç›£è½å™¨ (ç”¨æ–¼ç´°ç²’åº¦äº‹ä»¶)
        this.listeners = new Map();
        
        // æ­·å²è¨˜éŒ„ç®¡ç† - Linus å¼ç°¡æ½”è¨­è¨ˆ
        this.history = [];
        this.historyIndex = -1;
        this.maxHistorySize = 50;  // é¿å…è¨˜æ†¶é«”çˆ†ç‚¸
        this.isApplyingHistory = false;  // é˜²æ­¢å¾ªç’°
        
        console.log('ğŸ¯ History initialized:', {
            history: this.history,
            historyIndex: this.historyIndex,
            maxHistorySize: this.maxHistorySize,
            hasUndo: typeof this.undo === 'function',
            hasRedo: typeof this.redo === 'function',
            hasSaveSnapshot: typeof this.saveSnapshot === 'function'
        });
        
        // è¨‚é–±åŸºç¤ store è®Šæ›´
        this.baseStore.on('change', (state) => {
            this.emit('state:changed', state);
        });
    }
    
    // ========== ç‹€æ…‹ç²å– ==========
    
    getState() {
        return this.baseStore.getState();
    }
    
    getFlow() {
        const state = this.baseStore.getState();
        console.log('ğŸ” getFlow() called, state:', state);
        console.log('ğŸ” getFlow() returning currentFlow:', state.currentFlow);
        return state.currentFlow;
    }
    
    getSelectedCardId() {
        return this.baseStore.getState().selectedCardId;
    }
    
    isDirty() {
        return this.baseStore.getState().isDirty;
    }
    
    getVerbDefinitions() {
        return this.baseStore.getState().verbDefinitions;
    }
    
    // ========== Flow æ“ä½œ ==========
    
    updateFlow(updates) {
        const state = this.baseStore.getState();
        const newFlow = {
            ...state.currentFlow,
            ...updates
        };
        this.baseStore.setState({
            ...state,
            currentFlow: newFlow,
            isDirty: true
        });
        this.emit('flow:changed', newFlow);
    }
    
    updateMetadata(metadata) {
        const state = this.baseStore.getState();
        const newFlow = {
            ...state.currentFlow,
            metadata: {
                ...state.currentFlow.metadata,
                ...metadata
            }
        };
        this.baseStore.setState({
            ...state,
            currentFlow: newFlow,
            isDirty: true
        });
        this.emit('metadata:changed', newFlow.metadata);
    }
    
    updateVariables(variables) {
        const state = this.baseStore.getState();
        const newFlow = {
            ...state.currentFlow,
            variables: variables
        };
        this.baseStore.setState({
            ...state,
            currentFlow: newFlow,
            isDirty: true
        });
        this.emit('variables:changed', variables);
    }
    
    loadFlow(flowData) {
        console.log('ğŸ“¦ Store loadFlow called with:', flowData);
        console.log('ğŸ“¦ Flow array length:', flowData.flow ? flowData.flow.length : 'undefined');
        console.log('ğŸ“¦ Flow card IDs:', flowData.flow ? flowData.flow.map(c => c.id) : 'undefined');
        
        this.baseStore.setState({
            ...this.baseStore.getState(),
            currentFlow: flowData,
            isDirty: false,
            lastSaved: new Date().toISOString()
        });
        
        const stateAfter = this.baseStore.getState();
        console.log('ğŸ“¦ Store state after setState:', stateAfter.currentFlow.flow);
        console.log('ğŸ“¦ Store card IDs after setState:', stateAfter.currentFlow.flow.map(c => c.id));
        
        // Verify cards can be found by ID
        if (flowData.flow && flowData.flow.length > 0) {
            const firstCardId = flowData.flow[0].id;
            const foundCard = this.findCardById(firstCardId);
            console.log('ğŸ“¦ Verification - Can find first card by ID?', firstCardId, ':', !!foundCard);
        }
        
        this.emit('flow:loaded', flowData);
    }
    
    clearFlow() {
        console.log('ğŸ§¹ TAFLEditorStore.clearFlow() called');
        
        // Use the miniStore's clear() to properly clear localStorage
        // This resets to initial state and removes localStorage entry
        this.baseStore.clear();
        
        const newState = this.baseStore.getState();
        console.log('ğŸ§¹ Store cleared, current state:', newState);
        console.log('ğŸ§¹ Flow after clear:', newState.currentFlow);
        console.log('ğŸ§¹ Flow.flow after clear:', newState.currentFlow?.flow);
        console.log('ğŸ§¹ Flow.flow length:', newState.currentFlow?.flow?.length);
        
        // Emit the cleared event
        this.emit('flow:cleared');
    }
    
    // ========== Card æ“ä½œ ==========
    
    generateId() {
        const state = this.baseStore.getState();
        // Ensure cardCounter is a valid number
        let currentCounter = state.cardCounter;
        if (typeof currentCounter !== 'number' || isNaN(currentCounter)) {
            currentCounter = 0;
        }
        const newCounter = currentCounter + 1;
        
        // Update the counter immediately to ensure uniqueness
        this.baseStore.setState({
            ...state,
            cardCounter: newCounter
        });
        
        // Return an object with both id and newCounter as expected by addCard
        // Use both counter and timestamp for uniqueness
        const id = `card_${newCounter}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
        return { id, newCounter };
    }
    
    addCard(verb, position = null, params = {}) {
        console.log('ğŸ¯ [Store.addCard] Called with:', { verb, position, params });
        
        const state = this.baseStore.getState();
        const flow = state.currentFlow.flow;
        console.log('ğŸ¯ [Store.addCard] Current flow length:', flow.length);
        console.log('ğŸ¯ [Store.addCard] Current flow:', JSON.stringify(flow));
        
        const { id: cardId, newCounter } = this.generateId();
        console.log('ğŸ¯ [Store.addCard] Generated ID:', cardId, 'Counter:', newCounter);
        
        const newCard = {
            id: cardId,
            [verb]: params || {}
        };
        console.log('ğŸ¯ [Store.addCard] New card:', JSON.stringify(newCard));
        
        let newFlow;
        if (position && position.index !== undefined) {
            // åœ¨ç‰¹å®šä½ç½®æ’å…¥
            console.log('ğŸ¯ [Store.addCard] Inserting at index:', position.index);
            newFlow = [...flow];
            newFlow.splice(position.index, 0, newCard);
        } else {
            // æ·»åŠ åˆ°æœ«å°¾
            console.log('ğŸ¯ [Store.addCard] Adding to end');
            newFlow = [...flow, newCard];
        }
        
        console.log('ğŸ¯ [Store.addCard] New flow length:', newFlow.length);
        console.log('ğŸ¯ [Store.addCard] New flow:', JSON.stringify(newFlow));
        
        const updatedCurrentFlow = {
            ...state.currentFlow,
            flow: newFlow
        };
        
        console.log('ğŸ¯ [Store.addCard] Updated currentFlow:', JSON.stringify(updatedCurrentFlow));
        
        const newState = {
            ...state,
            currentFlow: updatedCurrentFlow,
            isDirty: true,
            cardCounter: newCounter  // Update the counter atomically with the flow
        };
        
        console.log('ğŸ¯ [Store.addCard] Setting state with new state:', JSON.stringify(newState));
        
        // Debug: Check if setState actually updates localStorage
        const lsBefore = localStorage.getItem('taflEditor');
        console.log('ğŸ¯ [Store.addCard] localStorage before setState:', lsBefore ? JSON.parse(lsBefore).currentFlow.flow.length + ' cards' : 'empty');
        
        this.baseStore.setState(newState);
        
        // ä¿å­˜å¿«ç…§ - å¿…é ˆåœ¨ç‹€æ…‹æ”¹è®Šå¾Œèª¿ç”¨
        this.saveSnapshot(`Add ${verb} card`);
        
        const lsAfter = localStorage.getItem('taflEditor');
        console.log('ğŸ¯ [Store.addCard] localStorage after setState:', lsAfter ? JSON.parse(lsAfter).currentFlow.flow.length + ' cards' : 'empty');
        console.log('ğŸ¯ [Store.addCard] State set complete');
        
        // Verify the state was actually updated
        const verifyState = this.baseStore.getState();
        console.log('ğŸ¯ [Store.addCard] VERIFY - State after setState:');
        console.log('ğŸ¯ [Store.addCard] VERIFY - Flow length:', verifyState.currentFlow.flow.length);
        console.log('ğŸ¯ [Store.addCard] VERIFY - Flow:', JSON.stringify(verifyState.currentFlow.flow));
        
        this.emit('card:added', {
            card: newCard,
            position: position || { index: newFlow.length - 1 }
        });
        
        return cardId;
    }
    
    updateCard(cardId, updates) {
        // ä¿å­˜å¿«ç…§
        this.saveSnapshot(`Update card ${cardId}`);
        
        const state = this.baseStore.getState();
        const card = this.findCardById(cardId);
        if (!card) return;
        
        // æ·±åº¦æ›´æ–°å¡ç‰‡
        const newFlow = this.updateCardInFlow(state.currentFlow.flow, cardId, updates);
        
        const updatedCurrentFlow = {
            ...state.currentFlow,
            flow: newFlow
        };
        
        this.baseStore.setState({
            ...state,
            currentFlow: updatedCurrentFlow,
            isDirty: true
        });
        
        // ä¿å­˜å¿«ç…§ - å¿…é ˆåœ¨ç‹€æ…‹æ”¹è®Šå¾Œèª¿ç”¨
        this.saveSnapshot(`Update card ${cardId}`);
        
        this.emit('card:updated', {
            cardId,
            cardData: { ...card, ...updates }
        });
    }
    
    deleteCard(cardId) {
        console.log('ğŸ—‘ï¸ TAFLEditorStore.deleteCard() called for:', cardId);
        
        const state = this.baseStore.getState();
        console.log('ğŸ“Š Current flow length before deletion:', state.currentFlow.flow.length);
        const newFlow = this.removeCardFromFlow(state.currentFlow.flow, cardId);
        console.log('ğŸ“Š New flow length after deletion:', newFlow.length);
        
        const updatedCurrentFlow = {
            ...state.currentFlow,
            flow: newFlow
        };
        
        let newSelectedId = state.selectedCardId;
        if (state.selectedCardId === cardId) {
            newSelectedId = null;
        }
        
        this.baseStore.setState({
            ...state,
            currentFlow: updatedCurrentFlow,
            selectedCardId: newSelectedId,
            isDirty: true
        });
        
        // ä¿å­˜å¿«ç…§ - å¿…é ˆåœ¨ç‹€æ…‹æ”¹è®Šå¾Œèª¿ç”¨
        this.saveSnapshot(`Delete card ${cardId}`);
        
        console.log('ğŸ“Š Store updated, emitting card:deleted event');
        this.emit('card:deleted', cardId);
    }
    
    moveCard(cardId, newPosition) {
        const state = this.baseStore.getState();
        const card = this.findCardById(cardId);
        if (!card) {
            console.error('âŒ moveCard: Card not found:', cardId);
            return;
        }
        
        // Deep clone the card to preserve all data (especially SET verb data)
        const cardToMove = JSON.parse(JSON.stringify(card));
        
        // Debug logging for SET cards
        const verb = Object.keys(cardToMove).find(k => !['id', 'comment'].includes(k));
        if (verb === 'set') {
            console.log('ğŸ” Moving SET card:', cardId, 'params type:', typeof cardToMove[verb], 'value:', cardToMove[verb]);
        }
        
        // å…ˆç§»é™¤å¡ç‰‡
        let newFlow = this.removeCardFromFlow(state.currentFlow.flow, cardId);
        
        // å†æ’å…¥åˆ°æ–°ä½ç½®
        if (newPosition.nested) {
            // æ’å…¥åˆ°åµŒå¥—ä½ç½®
            newFlow = this.insertCardInNested(newFlow, cardToMove, newPosition);
        } else {
            // æ’å…¥åˆ°é ‚å±¤ä½ç½®
            newFlow.splice(newPosition.index, 0, cardToMove);
        }
        
        // Verify SET card data after move
        if (verb === 'set') {
            const movedCard = this.findCardByIdInFlow(newFlow, cardId);
            if (movedCard) {
                console.log('âœ… SET card after move:', cardId, 'params type:', typeof movedCard[verb], 'value:', movedCard[verb]);
            }
        }
        
        const updatedCurrentFlow = {
            ...state.currentFlow,
            flow: newFlow
        };
        
        this.baseStore.setState({
            ...state,
            currentFlow: updatedCurrentFlow,
            isDirty: true
        });
        
        // ä¿å­˜å¿«ç…§ - å¿…é ˆåœ¨ç‹€æ…‹æ”¹è®Šå¾Œèª¿ç”¨
        this.saveSnapshot(`Move card ${cardId}`);
        
        this.emit('card:moved', {
            cardId,
            position: newPosition
        });
    }
    
    selectCard(cardId) {
        console.log('ğŸ¯ [STEP 8] Store.selectCard called with:', cardId);
        const state = this.baseStore.getState();
        console.log('ğŸ¯ [STEP 9] Current selectedCardId:', state.selectedCardId);
        
        const isSameCard = state.selectedCardId === cardId;
        if (isSameCard) {
            console.log('ğŸ¯ [STEP 9a] Same card already selected, but will emit event anyway for properties panel');
        }
        
        console.log('ğŸ¯ [STEP 10] Updating store state with selectedCardId:', cardId);
        // Only update selectedCardId, don't spread the entire state (which might be stale)
        this.baseStore.setState({
            selectedCardId: cardId
        });
        
        // ç²å–å¡ç‰‡è³‡æ–™
        const cardData = this.findCardById(cardId);
        console.log('ğŸ¯ [STEP 11] Found card data:', cardData ? 'Yes' : 'No');
        
        if (!cardData) {
            console.error('ğŸ¯ [ERROR] Card not found in store! cardId:', cardId);
            // åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„å¡ç‰‡ ID
            const allCardIds = [];
            const collectIds = (cards) => {
                if (!Array.isArray(cards)) return;
                cards.forEach(card => {
                    if (card.id) allCardIds.push(card.id);
                    // Check nested structures
                    const verb = Object.keys(card).find(k => !['id', 'comment'].includes(k));
                    if (verb && card[verb]) {
                        const params = card[verb];
                        if (params.then) collectIds(params.then);
                        if (params.else) collectIds(params.else);
                        if (params.do) collectIds(params.do);
                        if (params.cases) {
                            params.cases.forEach(c => {
                                if (c.do) collectIds(c.do);
                            });
                        }
                        if (params.default) collectIds(params.default);
                    }
                });
            };
            collectIds(state.currentFlow.flow);
            console.error('ğŸ¯ [ERROR] Available card IDs in store:', allCardIds);
        }
        
        console.log('ğŸ¯ [STEP 12] Emitting card:selected event');
        this.emit('card:selected', cardId);
        console.log('ğŸ¯ [STEP 13] Emitting selection:changed event with cardData');
        this.emit('selection:changed', { 
            cardId, 
            cardData 
        });
        console.log('ğŸ¯ [STEP 14] Store events emitted');
    }
    
    deselectCard() {
        const state = this.baseStore.getState();
        
        // å¦‚æœæ²’æœ‰é¸æ“‡ï¼Œä¸åšä»»ä½•äº‹
        if (!state.selectedCardId) return;
        
        // æ¸…é™¤é¸æ“‡
        // Only update selectedCardId, don't spread the entire state
        this.baseStore.setState({
            selectedCardId: null
        });
        
        // ç™¼å‡ºäº‹ä»¶
        this.emit('card:deselected');
        this.emit('selection:changed', { 
            cardId: null, 
            cardData: null 
        });
    }
    
    // ========== å±¬æ€§æ›´æ–°æ–¹æ³• ==========
    
    /**
     * æ›´æ–°å¡ç‰‡çš„å–®ä¸€å±¬æ€§
     * @param {string} cardId - å¡ç‰‡ID
     * @param {string} propertyPath - å±¬æ€§è·¯å¾‘ (æ”¯æ´å·¢ç‹€ï¼Œå¦‚ "switch.cases.0.when")
     * @param {any} value - æ–°å€¼
     */
    updateCardProperty(cardId, propertyPath, value) {
        const card = this.findCardById(cardId);
        if (!card) {
            console.error(`Card ${cardId} not found`);
            return;
        }
        
        // æ·±æ‹·è²å¡ç‰‡
        const updatedCard = JSON.parse(JSON.stringify(card));
        
        // è™•ç†å·¢ç‹€è·¯å¾‘
        const pathParts = propertyPath.split('.');
        let target = updatedCard;
        
        // å°èˆªåˆ°ç›®æ¨™å±¬æ€§çš„çˆ¶ç‰©ä»¶
        for (let i = 0; i < pathParts.length - 1; i++) {
            const part = pathParts[i];
            
            // è™•ç†é™£åˆ—ç´¢å¼•
            if (!isNaN(parseInt(part))) {
                target = target[parseInt(part)];
            } else {
                if (!target[part]) {
                    target[part] = {};
                }
                target = target[part];
            }
        }
        
        // è¨­å®šæœ€çµ‚å€¼
        const lastKey = pathParts[pathParts.length - 1];
        if (!isNaN(parseInt(lastKey))) {
            target[parseInt(lastKey)] = value;
        } else {
            target[lastKey] = value;
        }
        
        // æ›´æ–°åˆ° Store
        this.updateCard(cardId, updatedCard);
        
        // ç™¼å‡ºç´°ç²’åº¦äº‹ä»¶
        this.emit('property:updated', {
            cardId,
            propertyPath,
            value,
            cardData: this.findCardById(cardId)
        });
    }
    
    /**
     * æ‰¹é‡æ›´æ–°å±¬æ€§
     * @param {string} cardId - å¡ç‰‡ID
     * @param {Object} properties - è¦æ›´æ–°çš„å±¬æ€§é›†åˆ
     */
    updateCardProperties(cardId, properties) {
        const card = this.findCardById(cardId);
        if (!card) {
            console.error(`Card ${cardId} not found`);
            return;
        }
        
        // æ‰¹é‡æ›´æ–°
        Object.entries(properties).forEach(([path, value]) => {
            this.updateCardProperty(cardId, path, value);
        });
        
        // ç™¼å‡ºæ‰¹é‡æ›´æ–°äº‹ä»¶
        this.emit('properties:updated', {
            cardId,
            properties,
            cardData: this.findCardById(cardId)
        });
    }
    
    // ========== Switch-Case ç‰¹æ®Šæ“ä½œ ==========
    
    /**
     * æ·»åŠ  Switch Case
     * @param {string} cardId - Switch å¡ç‰‡ID
     * @returns {number} æ–° Case çš„ç´¢å¼•
     */
    addSwitchCase(cardId) {
        const card = this.findCardById(cardId);
        if (!card?.switch) {
            console.error(`Card ${cardId} is not a switch card`);
            return -1;
        }
        
        // æ–°å»º Case (æ³¨æ„ï¼šTAFL v1.1.1 ä½¿ç”¨ 'do' è€Œé 'then')
        const newCase = {
            when: '',
            do: []  // TAFL ä½¿ç”¨ 'do' è€Œé 'then'
        };
        
        // æ·»åŠ åˆ° cases é™£åˆ—ï¼Œä½†è¦ç¢ºä¿ default ä¿æŒåœ¨æœ€å¾Œ
        const existingCases = card.switch.cases || [];
        const defaultIndex = existingCases.findIndex(c => c.when === 'default');
        
        let cases;
        let newIndex;
        
        if (defaultIndex !== -1) {
            // æœ‰ defaultï¼Œæ’å…¥åœ¨å®ƒä¹‹å‰
            cases = [
                ...existingCases.slice(0, defaultIndex),
                newCase,
                ...existingCases.slice(defaultIndex)
            ];
            newIndex = defaultIndex; // æ–° case çš„ç´¢å¼•å°±æ˜¯åŸæœ¬ default çš„ä½ç½®
        } else {
            // æ²’æœ‰ defaultï¼ŒåŠ åœ¨æœ€å¾Œ
            cases = [...existingCases, newCase];
            newIndex = cases.length - 1;
        }
        
        // æ›´æ–°å¡ç‰‡ - åªæ›´æ–° switch å±¬æ€§
        this.updateCard(cardId, {
            switch: {
                ...card.switch,
                cases
            }
        });
        
        // ç™¼å‡ºäº‹ä»¶
        this.emit('switch:case-added', {
            cardId,
            caseIndex: newIndex,
            caseData: newCase
        });
        
        return newIndex;
    }
    
    /**
     * ç§»é™¤ Switch Case
     * @param {string} cardId - Switch å¡ç‰‡ID
     * @param {number} caseIndex - è¦ç§»é™¤çš„ Case ç´¢å¼•
     */
    removeSwitchCase(cardId, caseIndex) {
        const card = this.findCardById(cardId);
        if (!card?.switch?.cases) {
            console.error(`Card ${cardId} has no cases`);
            return;
        }
        
        // ç§»é™¤æŒ‡å®šçš„ Case
        const cases = card.switch.cases.filter((_, index) => index !== caseIndex);
        
        // æ›´æ–°å¡ç‰‡ - åªæ›´æ–° switch å±¬æ€§
        this.updateCard(cardId, {
            switch: {
                ...card.switch,
                cases
            }
        });
        
        // ç™¼å‡ºäº‹ä»¶
        this.emit('switch:case-removed', {
            cardId,
            caseIndex
        });
    }
    
    /**
     * æ·»åŠ  Switch Default (TAFL v1.1.1 è¦ç¯„: default æ˜¯ç‰¹æ®Šçš„ caseï¼Œwhen: "default")
     * @param {string} cardId - Switch å¡ç‰‡ID
     */
    addSwitchDefault(cardId) {
        console.log('ğŸ”§ [STORE] addSwitchDefault called for', cardId);
        const card = this.findCardById(cardId);
        if (!card?.switch) {
            console.error(`Card ${cardId} is not a switch card`);
            return;
        }
        
        // æª¢æŸ¥æ˜¯å¦å·²æœ‰ default case
        const hasDefault = card.switch.cases?.some(c => c.when === 'default');
        if (hasDefault) {
            console.warn('Switch already has a default case');
            return;
        }
        
        // æ ¹æ“š TAFL v1.1.1ï¼Œdefault æ˜¯ç‰¹æ®Šçš„ caseï¼Œæ”¾åœ¨æœ€å¾Œ
        const defaultCase = {
            when: 'default',
            do: []  // TAFL ä½¿ç”¨ 'do' è€Œé 'then'
        };
        
        const cases = [...(card.switch.cases || []), defaultCase];
        
        // æ›´æ–°å¡ç‰‡ï¼Œç§»é™¤èˆŠçš„ default å­—æ®µï¼ˆå¦‚æœæœ‰ï¼‰
        const { default: _, ...switchWithoutDefault } = card.switch;
        
        // åªæ›´æ–° switch å±¬æ€§ï¼Œä¸è¦å‚³éæ•´å€‹å¡ç‰‡
        this.updateCard(cardId, {
            switch: {
                ...switchWithoutDefault,
                cases
            }
        });
        
        // ç™¼å‡ºäº‹ä»¶
        this.emit('switch:default-added', { cardId });
    }
    
    /**
     * ç§»é™¤ Switch Default (TAFL v1.1.1 è¦ç¯„: ç§»é™¤ when: "default" çš„ case)
     * @param {string} cardId - Switch å¡ç‰‡ID
     */
    removeSwitchDefault(cardId) {
        console.log('ğŸ”§ [STORE] removeSwitchDefault called for', cardId);
        const card = this.findCardById(cardId);
        if (!card?.switch?.cases) {
            console.error(`Card ${cardId} is not a switch card or has no cases`);
            return;
        }
        
        // ç§»é™¤ when: "default" çš„ case
        const cases = card.switch.cases.filter(c => c.when !== 'default');
        
        // æ›´æ–°å¡ç‰‡ï¼ŒåŒæ™‚ç§»é™¤èˆŠçš„ default å­—æ®µï¼ˆå¦‚æœæœ‰ï¼‰
        const { default: _, ...switchWithoutDefault } = card.switch;
        
        // åªæ›´æ–° switch å±¬æ€§ï¼Œä¸è¦å‚³éæ•´å€‹å¡ç‰‡
        this.updateCard(cardId, {
            switch: {
                ...switchWithoutDefault,
                cases
            }
        });
        
        // ç™¼å‡ºäº‹ä»¶
        this.emit('switch:default-removed', { cardId });
    }
    
    /**
     * ç§»å‹• Switch Case é †åº
     * @param {string} cardId - Switch å¡ç‰‡ID
     * @param {number} fromIndex - åŸç´¢å¼•
     * @param {number} toIndex - ç›®æ¨™ç´¢å¼•
     */
    moveSwitchCase(cardId, fromIndex, toIndex) {
        const card = this.findCardById(cardId);
        if (!card?.switch?.cases) {
            console.error(`Card ${cardId} has no cases`);
            return;
        }
        
        const cases = [...card.switch.cases];
        
        // ç§»å‹•å…ƒç´ 
        const [movedCase] = cases.splice(fromIndex, 1);
        cases.splice(toIndex, 0, movedCase);
        
        // æ›´æ–°å¡ç‰‡ - åªæ›´æ–° switch å±¬æ€§
        this.updateCard(cardId, {
            switch: {
                ...card.switch,
                cases
            }
        });
        
        // ç™¼å‡ºäº‹ä»¶
        this.emit('switch:case-moved', {
            cardId,
            fromIndex,
            toIndex
        });
    }
    
    // ========== æŸ¥è©¢æ–¹æ³• ==========
    
    findCardById(cardId) {
        console.log(`ğŸ” [findCardById] Looking for card: ${cardId}`);
        
        // Debug the state
        const currentFlow = this.getFlow();
        console.log('ğŸ” [findCardById] currentFlow:', currentFlow);
        console.log('ğŸ” [findCardById] currentFlow.flow:', currentFlow?.flow);
        console.log('ğŸ” [findCardById] flow array length:', currentFlow?.flow?.length);
        
        if (!currentFlow || !currentFlow.flow) {
            console.error('ğŸ” [findCardById] ERROR: No flow data available!');
            return null;
        }
        
        const flow = currentFlow.flow;
        const result = this.findCardInArray(flow, cardId);
        console.log(`ğŸ” [findCardById] Found card: ${result ? 'YES' : 'NO'}`, result);
        
        return result;
    }
    
    findCardByIdInFlow(flow, cardId) {
        console.log(`ğŸ” [findCardByIdInFlow] Looking for card: ${cardId} in specific flow`);
        
        if (!flow || !Array.isArray(flow)) {
            console.error('ğŸ” [findCardByIdInFlow] ERROR: Invalid flow array!');
            return null;
        }
        
        const result = this.findCardInArray(flow, cardId);
        console.log(`ğŸ” [findCardByIdInFlow] Found card: ${result ? 'YES' : 'NO'}`, result);
        
        return result;
    }
    
    findCardInArray(cards, cardId) {
        for (const card of cards) {
            if (card.id === cardId) {
                return card;
            }
            
            // åªæœ‰ç•¶å°è±¡æœ‰ id å±¬æ€§æ™‚æ‰æ˜¯çœŸæ­£çš„å¡ç‰‡ï¼Œæ‰é€²è¡ŒåµŒå¥—æœç´¢
            if (!card.id) {
                continue;  // è·³ééå¡ç‰‡å°è±¡ï¼ˆå¦‚ switch çš„ case é …ï¼‰
            }
            
            // æœå°‹åµŒå¥—çµæ§‹
            const verb = this.getCardVerb(card);
            if (verb && card[verb]) {
                const params = card[verb];
                
                // æª¢æŸ¥å„ç¨®åµŒå¥—çµæ§‹ - ä½¿ç”¨æ­£ç¢ºçš„å±¬æ€§åç¨±
                // æ³¨æ„: 'cases' éœ€è¦ç‰¹æ®Šè™•ç†ï¼Œä¸èƒ½ç›´æ¥å‚³é
                for (const key of ['then', 'else', 'do', 'default']) {
                    if (params[key] && Array.isArray(params[key])) {
                        const found = this.findCardInArray(params[key], cardId);
                        if (found) return found;
                    }
                }
                
                // æª¢æŸ¥ switch cases çš„ç‰¹æ®Šçµæ§‹
                if (params.cases && Array.isArray(params.cases)) {
                    for (const caseItem of params.cases) {
                        if (caseItem.do && Array.isArray(caseItem.do)) {
                            const found = this.findCardInArray(caseItem.do, cardId);
                            if (found) return found;
                        }
                    }
                }
            }
        }
        return null;
    }
    
    getCardVerb(cardData) {
        if (!cardData) return null;
        
        const nonVerbKeys = ['id', 'comment', 'skip_if', 'store_as', 'as'];
        
        // ç¡¬ç·¨ç¢¼çš„ TAFL å‹•è©åˆ—è¡¨ä½œç‚ºå‚™ç”¨
        // ç¢ºä¿å³ä½¿ verbDefinitions æœªè¼‰å…¥ä¹Ÿèƒ½è­˜åˆ¥
        const knownVerbs = [
            'query', 'check', 'create', 'update', 
            'if',     // æ˜ç¢ºåŒ…å« if
            'for', 'switch', 'set', 'stop', 'notify'
        ];
        
        const verbDefs = this.getVerbDefinitions();
        
        // å„ªå…ˆä½¿ç”¨ verbDefinitions
        if (verbDefs) {
            const foundVerb = Object.keys(cardData).find(key => 
                !nonVerbKeys.includes(key) && verbDefs[key]
            );
            if (foundVerb) return foundVerb;
        }
        
        // å‚™ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ç¡¬ç·¨ç¢¼çš„å·²çŸ¥å‹•è©åˆ—è¡¨
        const foundVerb = Object.keys(cardData).find(key => 
            knownVerbs.includes(key)
        );
        if (foundVerb) return foundVerb;
        
        // æœ€çµ‚å‚™ç”¨ï¼šä»»ä½•éæ’é™¤éµï¼ˆä¿æŒå‘å¾Œç›¸å®¹ï¼‰
        for (const key of Object.keys(cardData)) {
            if (!nonVerbKeys.includes(key)) {
                console.warn(`Using fallback for unrecognized verb: ${key}`);
                return key;
            }
        }
        
        return null;
    }
    
    // ========== è¼”åŠ©æ–¹æ³• ==========
    
    updateCardInFlow(cards, cardId, updates) {
        return cards.map(card => {
            if (card.id === cardId) {
                return { ...card, ...updates };
            }
            
            // åªæœ‰ç•¶å°è±¡æœ‰ id å±¬æ€§æ™‚æ‰æ˜¯çœŸæ­£çš„å¡ç‰‡ï¼Œæ‰è™•ç†åµŒå¥—çµæ§‹
            if (!card.id) {
                return card;  // ä¸æ˜¯å¡ç‰‡ï¼Œç›´æ¥è¿”å›
            }
            
            // è™•ç†åµŒå¥—çµæ§‹
            const verb = this.getCardVerb(card);
            if (verb && card[verb]) {
                const params = card[verb];
                // Handle string params (like 'set' verb) correctly
                const updatedParams = typeof params === 'string' ? params : { ...params };
                
                // Only process nested structures if params is an object
                if (typeof params === 'object') {
                    // æ³¨æ„ï¼šä¸è¦ç›´æ¥è™•ç† 'cases'ï¼Œå®ƒéœ€è¦ç‰¹æ®Šè™•ç†
                    for (const key of ['then', 'else', 'do', 'default']) {
                        if (params[key] && Array.isArray(params[key])) {
                            updatedParams[key] = this.updateCardInFlow(params[key], cardId, updates);
                        }
                    }
                    
                    // è™•ç† switch cases çš„ç‰¹æ®Šçµæ§‹
                    if (params.cases && Array.isArray(params.cases)) {
                        updatedParams.cases = params.cases.map(caseItem => {
                            if (caseItem.do && Array.isArray(caseItem.do)) {
                                return {
                                    ...caseItem,
                                    do: this.updateCardInFlow(caseItem.do, cardId, updates)
                                };
                            }
                            return caseItem;
                        });
                    }
                }
                
                return {
                    ...card,
                    [verb]: updatedParams
                };
            }
            
            return card;
        });
    }
    
    removeCardFromFlow(cards, cardId) {
        const result = [];
        
        for (const card of cards) {
            if (card.id === cardId) {
                continue; // è·³éè¦åˆªé™¤çš„å¡ç‰‡
            }
            
            // è™•ç†åµŒå¥—çµæ§‹
            const verb = this.getCardVerb(card);
            if (verb && card[verb]) {
                const params = card[verb];
                // Handle string params (like 'set' verb) correctly
                const updatedParams = typeof params === 'string' ? params : { ...params };
                
                // Only process nested structures if params is an object
                if (typeof params === 'object') {
                    // ä½¿ç”¨èˆ‡ insertCardInNested ç›¸åŒçš„éµååˆ—è¡¨ï¼ˆç§»é™¤ defaultï¼Œå› ç‚ºå®ƒç¾åœ¨æ˜¯ case çš„ä¸€éƒ¨åˆ†ï¼‰
                    for (const key of ['then', 'else', 'do', 'body', 'steps', 'catch', 'finally', 'cases']) {
                        if (params[key] && Array.isArray(params[key])) {
                            updatedParams[key] = this.removeCardFromFlow(params[key], cardId);
                        }
                    }
                    
                    // è™•ç† switch cases çš„ç‰¹æ®Šçµæ§‹
                    if (params.cases && Array.isArray(params.cases)) {
                        updatedParams.cases = params.cases.map(caseItem => {
                            if (caseItem.do && Array.isArray(caseItem.do)) {
                                return {
                                    ...caseItem,
                                    do: this.removeCardFromFlow(caseItem.do, cardId)
                                };
                            }
                            return caseItem;
                        });
                    }
                }
                
                result.push({
                    ...card,
                    [verb]: updatedParams
                });
            } else {
                result.push(card);
            }
        }
        
        return result;
    }
    
    insertCardInNested(cards, newCard, position) {
        return cards.map(card => {
            // æ”¯æ´å…©ç¨®å±¬æ€§åç¨±æ ¼å¼ï¼ˆå‘å¾Œç›¸å®¹ï¼‰
            const parentId = position.nested.parentCardId || position.nested.parentId;
            const branchName = position.nested.branchType || position.nested.branch;
            
            if (card.id === parentId) {
                const verb = this.getCardVerb(card);
                if (verb && card[verb]) {
                    const params = card[verb];
                    // Handle string params (like 'set' verb) correctly
                    const updatedParams = typeof params === 'string' ? params : { ...params };
                    
                    // Only update nested structures if params is an object
                    if (typeof params === 'object') {
                        // Special handling for switch cases (branchName like "case-0", "case-1", or "default")
                        if (verb === 'switch' && (branchName.startsWith('case-') || branchName === 'default')) {
                            console.log('ğŸ”´ insertCardInNested - handling switch case:', branchName);
                            
                            let caseIndex;
                            if (branchName === 'default') {
                                // Find the default case (when === 'default')
                                caseIndex = updatedParams.cases?.findIndex(c => c.when === 'default');
                                console.log('ğŸ”´ Default case index:', caseIndex);
                            } else {
                                caseIndex = parseInt(branchName.split('-')[1]);
                                console.log('ğŸ”´ Case index:', caseIndex, 'Position index:', position.index);
                            }
                            
                            if (updatedParams.cases && updatedParams.cases[caseIndex]) {
                                // Deep clone the cases array
                                updatedParams.cases = updatedParams.cases.map((c, i) => {
                                    if (i === caseIndex) {
                                        const updatedCase = { ...c };
                                        if (!updatedCase.do) {
                                            updatedCase.do = [];
                                        }
                                        // Clone the do array and insert at the specified index
                                        updatedCase.do = [...updatedCase.do];
                                        const insertIndex = typeof position.index === 'number' ? position.index : 0;
                                        console.log('ğŸ”´ Inserting at index:', insertIndex, 'into case', caseIndex);
                                        updatedCase.do.splice(insertIndex, 0, newCard);
                                        return updatedCase;
                                    }
                                    return c;
                                });
                            }
                        } else {
                            // Normal nested structure handling (then, else, do, etc.)
                            const branchKey = branchName;
                            if (!updatedParams[branchKey]) {
                                updatedParams[branchKey] = [];
                            }
                            
                            updatedParams[branchKey] = [...updatedParams[branchKey]];
                            updatedParams[branchKey].splice(position.index || 0, 0, newCard);
                        }
                    }
                    
                    return {
                        ...card,
                        [verb]: updatedParams
                    };
                }
            }
            
            // éè¿´è™•ç†åµŒå¥—çµæ§‹
            const verb = this.getCardVerb(card);
            if (verb && card[verb]) {
                const params = card[verb];
                // Handle string params (like 'set' verb) correctly
                const updatedParams = typeof params === 'string' ? params : { ...params };
                
                // Only process nested structures if params is an object
                if (typeof params === 'object') {
                    // ä½¿ç”¨æ­£ç¢ºçš„ TAFL éµå: then, else, do, catch, finally ç­‰
                    for (const key of ['then', 'else', 'do', 'body', 'steps', 'catch', 'finally']) {
                        if (params[key] && Array.isArray(params[key])) {
                            updatedParams[key] = this.insertCardInNested(params[key], newCard, position);
                        }
                    }
                    
                    // Handle switch cases recursively
                    if (verb === 'switch' && params.cases && Array.isArray(params.cases)) {
                        updatedParams.cases = params.cases.map(caseItem => {
                            if (caseItem.do && Array.isArray(caseItem.do)) {
                                return {
                                    ...caseItem,
                                    do: this.insertCardInNested(caseItem.do, newCard, position)
                                };
                            }
                            return caseItem;
                        });
                    }
                }
                
                return {
                    ...card,
                    [verb]: updatedParams
                };
            }
            
            return card;
        });
    }
    
    // ========== å…¶ä»–æ“ä½œ ==========
    
    setVerbDefinitions(verbs) {
        const state = this.baseStore.getState();
        this.baseStore.setState({
            ...state,
            verbDefinitions: verbs
        });
        this.emit('verbs:loaded', verbs);
    }
    
    setDirty(isDirty) {
        const state = this.baseStore.getState();
        this.baseStore.setState({
            ...state,
            isDirty
        });
        this.emit('dirty:changed', isDirty);
    }
    
    setSaved() {
        const state = this.baseStore.getState();
        this.baseStore.setState({
            ...state,
            isDirty: false,
            lastSaved: new Date().toISOString()
        });
        this.emit('flow:saved');
    }
    
    // ========== äº‹ä»¶ç®¡ç† ==========
    
    on(event, callback) {
        console.log(`ğŸ”” [Store.on] Registering listener for event: ${event}`);
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event).add(callback);
        console.log(`ğŸ”” [Store.on] Total listeners for ${event}: ${this.listeners.get(event).size}`);
    }
    
    off(event, callback) {
        const listeners = this.listeners.get(event);
        if (listeners) {
            listeners.delete(callback);
            if (listeners.size === 0) {
                this.listeners.delete(event);
            }
        }
    }
    
    emit(event, data) {
        console.log(`ğŸ”” [Store.emit] Emitting event: ${event}`, data);
        const listeners = this.listeners.get(event);
        console.log(`ğŸ”” [Store.emit] Listeners for ${event}:`, listeners ? listeners.size : 0);
        if (listeners) {
            listeners.forEach(callback => {
                try {
                    console.log(`ğŸ”” [Store.emit] Calling listener for ${event}`);
                    callback(data);
                } catch (error) {
                    console.error(`Error in event handler for ${event}:`, error);
                }
            });
        } else {
            console.log(`ğŸ”” [Store.emit] No listeners registered for ${event}`);
        }
    }
    
    // ========== æ‰¹æ¬¡æ›´æ–° ==========
    
    batchUpdate(updateFn) {
        // æš«æ™‚ç¦ç”¨äº‹ä»¶
        const originalEmit = this.emit;
        const pendingEvents = [];
        
        this.emit = (event, data) => {
            pendingEvents.push({ event, data });
        };
        
        try {
            // åŸ·è¡Œæ‰¹æ¬¡æ›´æ–°
            updateFn();
            
            // æ¢å¾©äº‹ä»¶ç™¼é€
            this.emit = originalEmit;
            
            // ç™¼é€æ‰¹æ¬¡äº‹ä»¶
            this.emit('batch:updated', pendingEvents);
            
            // ç™¼é€å€‹åˆ¥äº‹ä»¶
            pendingEvents.forEach(({ event, data }) => {
                this.emit(event, data);
            });
        } catch (error) {
            this.emit = originalEmit;
            throw error;
        }
    }
    
    // ========== æ­·å²ç®¡ç† (Undo/Redo) ==========
    
    /**
     * ä¿å­˜ç‹€æ…‹å¿«ç…§ - ç°¡å–®ç›´æ¥ï¼Œä¸æèŠ±å“¨
     */
    saveSnapshot(description = '') {
        // é˜²æ­¢æ­·å²æ“ä½œè§¸ç™¼æ–°å¿«ç…§
        if (this.isApplyingHistory) return;
        
        const state = this.getState();
        const snapshot = {
            timestamp: Date.now(),
            description,
            // æ·±æ‹·è²æ•´å€‹ flow - ç°¡å–®ç²—æš´ä½†æœ‰æ•ˆ
            flow: JSON.parse(JSON.stringify(state.currentFlow))
        };
        
        // å¦‚æœæœ‰æ’¤éŠ·éï¼Œæ¸…ç†ä¹‹å¾Œçš„æ­·å²
        if (this.historyIndex < this.history.length - 1) {
            this.history = this.history.slice(0, this.historyIndex + 1);
        }
        
        // æ·»åŠ æ–°å¿«ç…§
        this.history.push(snapshot);
        this.historyIndex++;
        
        // é™åˆ¶æ­·å²å¤§å°
        if (this.history.length > this.maxHistorySize) {
            this.history.shift();
            this.historyIndex--;
        }
        
        this.emit('history:changed', {
            canUndo: this.canUndo(),
            canRedo: this.canRedo()
        });
    }
    
    /**
     * æ’¤éŠ· - å›åˆ°ä¸Šä¸€å€‹ç‹€æ…‹
     */
    undo() {
        if (!this.canUndo()) return false;
        
        this.historyIndex--;
        this.isApplyingHistory = true;
        
        const snapshot = this.history[this.historyIndex];
        this.baseStore.setState({
            ...this.getState(),
            currentFlow: JSON.parse(JSON.stringify(snapshot.flow)),
            selectedCardId: null  // æ¸…é™¤é¸æ“‡
        });
        
        this.isApplyingHistory = false;
        this.emit('history:undo', snapshot);
        this.emit('history:changed', {
            canUndo: this.canUndo(),
            canRedo: this.canRedo()
        });
        return true;
    }
    
    /**
     * é‡åš - å‰é€²åˆ°ä¸‹ä¸€å€‹ç‹€æ…‹
     */
    redo() {
        if (!this.canRedo()) return false;
        
        this.historyIndex++;
        this.isApplyingHistory = true;
        
        const snapshot = this.history[this.historyIndex];
        this.baseStore.setState({
            ...this.getState(),
            currentFlow: JSON.parse(JSON.stringify(snapshot.flow)),
            selectedCardId: null  // æ¸…é™¤é¸æ“‡
        });
        
        this.isApplyingHistory = false;
        this.emit('history:redo', snapshot);
        this.emit('history:changed', {
            canUndo: this.canUndo(),
            canRedo: this.canRedo()
        });
        return true;
    }
    
    /**
     * æª¢æŸ¥æ˜¯å¦å¯ä»¥æ’¤éŠ·
     */
    canUndo() {
        return this.historyIndex > 0;
    }
    
    /**
     * æª¢æŸ¥æ˜¯å¦å¯ä»¥é‡åš
     */
    canRedo() {
        return this.historyIndex < this.history.length - 1;
    }
    
    /**
     * æ¸…é™¤æ­·å²è¨˜éŒ„
     */
    clearHistory() {
        this.history = [];
        this.historyIndex = -1;
        this.emit('history:changed', {
            canUndo: false,
            canRedo: false
        });
    }
}

// å‰µå»ºä¸¦å°å‡ºå–®ä¾‹
export const taflFlowStore = new TAFLFlowStore();