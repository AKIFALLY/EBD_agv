/**
 * TAFL Editor Properties Module
 * äº‹ä»¶é©…å‹•çš„å±¬æ€§ç·¨è¼¯æ ¸å¿ƒå¼•æ“
 * è² è²¬æ¥­å‹™é‚è¼¯å’Œå…§å®¹ç”Ÿæˆï¼Œä¸ç›´æ¥æ“ä½œ DOM
 */

import { taflFlowStore } from './tafl-editor-store.js?v=20250105140500';

class TAFLEditorProperties {
    constructor() {
        this.verbDefinitions = null;  // å°‡å¾ä¸»æ¨¡çµ„æ³¨å…¥
        this.currentCardId = null;
        this.listeners = new Map();
        this.debouncedUpdater = new DebouncedUpdater(300);
        
        // è¨‚é–± Store äº‹ä»¶
        this.bindStoreEvents();
    }
    
    // ========================================
    // Store äº‹ä»¶è¨‚é–±
    // ========================================
    
    bindStoreEvents() {
        console.log('ğŸ¯ [INIT] Properties: Binding store events');
        // éŸ¿æ‡‰é¸æ“‡è®ŠåŒ–
        taflFlowStore.on('selection:changed', ({ cardId, cardData }) => {
            console.log('ğŸ¯ [STEP 15] Properties: Received selection:changed event for', cardId);
            this.handleSelectionChanged(cardId, cardData);
        });
        
        // éŸ¿æ‡‰å¡ç‰‡æ›´æ–°
        taflFlowStore.on('card:updated', ({ cardId, cardData }) => {
            if (cardId === this.currentCardId) {
                console.log('ğŸ“ Properties: Current card updated', cardId);
                this.handleCardUpdated(cardData);
            }
        });
        
        // éŸ¿æ‡‰å±¬æ€§æ›´æ–°
        taflFlowStore.on('property:updated', ({ cardId, propertyPath, value }) => {
            if (cardId === this.currentCardId) {
                console.log('ğŸ“ Properties: Property updated', propertyPath, '=', value);
                this.handlePropertyUpdated(propertyPath, value);
            }
        });
        
        // éŸ¿æ‡‰ Switch-Case è®Šæ›´
        taflFlowStore.on('switch:case-added', ({ cardId, caseIndex }) => {
            if (cardId === this.currentCardId) {
                this.handleCaseAdded(caseIndex);
            }
        });
        
        taflFlowStore.on('switch:case-removed', ({ cardId, caseIndex }) => {
            if (cardId === this.currentCardId) {
                this.handleCaseRemoved(caseIndex);
            }
        });
    }
    
    // ========================================
    // äº‹ä»¶è™•ç†
    // ========================================
    
    handleSelectionChanged(cardId, cardData) {
        console.log('ğŸ¯ [STEP 16] Properties: handleSelectionChanged called');
        this.currentCardId = cardId;
        
        if (!cardId) {
            console.log('ğŸ¯ [STEP 16a] No cardId, emitting render:empty');
            this.emit('render:empty');
            return;
        }
        
        console.log('ğŸ¯ [STEP 17] Properties: Rendering property editor');
        const html = this.renderPropertyEditor(cardData);
        console.log('ğŸ¯ [STEP 18] Properties: HTML generated, length:', html?.length);
        
        console.log('ğŸ¯ [STEP 19] Properties: Emitting render:complete event');
        this.emit('render:complete', { 
            html, 
            cardData,
            cardId 
        });
        console.log('ğŸ¯ [STEP 20] Properties: render:complete emitted');
    }
    
    handleCardUpdated(cardData) {
        // å®Œæ•´é‡ç¹ª
        const html = this.renderPropertyEditor(cardData);
        this.emit('render:update', { 
            html, 
            cardData,
            cardId: this.currentCardId 
        });
    }
    
    handlePropertyUpdated(propertyPath, value) {
        // ç™¼å‡ºå±€éƒ¨æ›´æ–°äº‹ä»¶ï¼ˆUIå¯é¸æ“‡æ€§éŸ¿æ‡‰ï¼‰
        this.emit('property:changed', { 
            propertyPath, 
            value,
            cardId: this.currentCardId 
        });
    }
    
    handleCaseAdded(caseIndex) {
        // é‡ç¹ª Switch ç·¨è¼¯å™¨
        const cardData = taflFlowStore.findCardById(this.currentCardId);
        if (cardData) {
            this.handleCardUpdated(cardData);
        }
    }
    
    handleCaseRemoved(caseIndex) {
        // é‡ç¹ª Switch ç·¨è¼¯å™¨
        const cardData = taflFlowStore.findCardById(this.currentCardId);
        if (cardData) {
            this.handleCardUpdated(cardData);
        }
    }
    
    // ========================================
    // æ¸²æŸ“æ–¹æ³•ï¼ˆç´”å‡½æ•¸ï¼Œç„¡å‰¯ä½œç”¨ï¼‰
    // ========================================
    
    renderPropertyEditor(cardData) {
        console.log('ğŸ¯ [RENDER-1] renderPropertyEditor called with:', cardData);
        if (!cardData) {
            console.log('ğŸ¯ [RENDER-1a] No cardData, returning empty string');
            return '';
        }
        
        // Ensure verbDefinitions are loaded
        if (!this.verbDefinitions) {
            console.warn('ğŸ¯ [RENDER-2] verbDefinitions not set, attempting to load from store');
            this.verbDefinitions = taflFlowStore.getVerbDefinitions();
            console.log('ğŸ¯ [RENDER-2a] Loaded verbDefinitions:', this.verbDefinitions);
            if (!this.verbDefinitions) {
                console.warn('ğŸ¯ [RENDER-2b] Still no verbDefinitions, using empty object');
                this.verbDefinitions = {};
            }
        }
        
        const verb = this.getCardVerb(cardData);
        console.log('ğŸ¯ [RENDER-3] Found verb:', verb, 'for card:', cardData.id);
        if (!verb) {
            console.error('ğŸ¯ [RENDER-3a] No verb found for card:', cardData);
            return '<div class="has-text-danger">Invalid card data</div>';
        }
        
        // Switch ç‰¹æ®Šè™•ç†
        if (verb === 'switch') {
            console.log('ğŸ¯ [RENDER-4] Rendering switch editor');
            return this.renderSwitchCasesEditor(cardData);
        }
        
        // ä¸€èˆ¬å±¬æ€§ç·¨è¼¯å™¨
        console.log('ğŸ¯ [RENDER-5] Rendering standard editor for verb:', verb);
        const result = this.renderStandardEditor(cardData, verb);
        console.log('ğŸ¯ [RENDER-6] Generated HTML length:', result?.length);
        return result;
    }
    
    renderStandardEditor(cardData, verb) {
        console.log('ğŸ¯ [STD-1] renderStandardEditor called for verb:', verb);
        const params = cardData[verb] || {};
        console.log('ğŸ¯ [STD-2] Card params:', params);
        const verbDef = this.verbDefinitions?.[verb];
        console.log('ğŸ¯ [STD-3] Verb definition:', verbDef);
        
        let html = '<div class="property-fields">';
        console.log('ğŸ¯ [STD-4] Starting HTML generation');
        
        // Get all available parameters for this verb
        const availableParams = verbDef?.params || [];
        console.log('ğŸ¯ [STD-4a] Available params for verb:', availableParams);
        
        // å„ªå…ˆé¡¯ç¤ºçš„åƒæ•¸
        const priorityParams = ['target', 'condition', 'expression', 'value'];
        const renderedParams = new Set();
        
        // å…ˆæ¸²æŸ“å„ªå…ˆåƒæ•¸ï¼ˆå¦‚æœå®ƒå€‘åœ¨å¯ç”¨åƒæ•¸åˆ—è¡¨ä¸­ï¼‰
        console.log('ğŸ¯ [STD-5] Rendering priority params:', priorityParams);
        for (const key of priorityParams) {
            if (availableParams.includes(key)) {
                const value = params[key] || '';  // Use empty string if no value
                console.log('ğŸ¯ [STD-5a] Rendering priority param:', key, '=', value);
                html += this.renderPropertyField(cardData.id, verb, key, value);
                renderedParams.add(key);
            }
        }
        
        // æ¸²æŸ“å…¶ä»–å¯ç”¨åƒæ•¸
        console.log('ğŸ¯ [STD-6] Rendering other available params');
        for (const key of availableParams) {
            if (renderedParams.has(key)) continue;
            if (this.isInternalProperty(key)) continue;
            
            const value = params[key] || '';  // Use empty string if no value
            console.log('ğŸ¯ [STD-6a] Rendering param:', key, '=', value);
            html += this.renderPropertyField(cardData.id, verb, key, value);
            renderedParams.add(key);
        }
        
        // Also render any extra params that are in the data but not in the definition
        for (const [key, value] of Object.entries(params)) {
            if (renderedParams.has(key)) continue;
            if (this.isInternalProperty(key)) continue;
            
            console.log('ğŸ¯ [STD-6b] Rendering extra param:', key, '=', value);
            html += this.renderPropertyField(cardData.id, verb, key, value);
        }
        
        html += '</div>';
        console.log('ğŸ¯ [STD-7] Final HTML length:', html.length);
        return html;
    }
    
    renderPropertyField(cardId, verb, key, value) {
        const fieldId = `prop-${cardId}-${key}`;
        const paramHelp = this.getParamHelp(verb, key);
        
        // æ ¹æ“šåƒæ•¸é¡å‹æ¸²æŸ“ä¸åŒçš„è¼¸å…¥å…ƒä»¶
        let inputHTML = this.renderInputByType(fieldId, cardId, verb, key, value);
        
        return `
            <div class="field">
                <label class="label" for="${fieldId}">
                    ${this.formatParamName(key)}
                </label>
                <div class="control">
                    ${inputHTML}
                </div>
                ${paramHelp ? `<p class="help">${paramHelp}</p>` : ''}
            </div>
        `;
    }
    
    renderInputByType(fieldId, cardId, verb, key, value) {
        const paramType = this.getParamType(verb, key);
        
        switch (paramType) {
            case 'boolean':
                return `
                    <label class="checkbox">
                        <input 
                            id="${fieldId}"
                            type="checkbox"
                            class="property-input"
                            data-card-id="${cardId}"
                            data-verb="${verb}"
                            data-property="${key}"
                            ${value ? 'checked' : ''}
                        />
                        ${this.formatParamName(key)}
                    </label>
                `;
                
            case 'number':
                return `
                    <input 
                        id="${fieldId}"
                        class="input property-input" 
                        type="number"
                        data-card-id="${cardId}"
                        data-verb="${verb}"
                        data-property="${key}"
                        value="${this.escapeHtml(String(value || 0))}"
                    />
                `;
                
            case 'select':
                const options = this.getParamOptions(verb, key);
                return `
                    <div class="select">
                        <select 
                            id="${fieldId}"
                            class="property-input"
                            data-card-id="${cardId}"
                            data-verb="${verb}"
                            data-property="${key}"
                        >
                            ${options.map(opt => `
                                <option value="${opt.value}" ${value === opt.value ? 'selected' : ''}>
                                    ${opt.label}
                                </option>
                            `).join('')}
                        </select>
                    </div>
                `;
                
            case 'multiline':
                return `
                    <textarea 
                        id="${fieldId}"
                        class="textarea property-input"
                        rows="3"
                        data-card-id="${cardId}"
                        data-verb="${verb}"
                        data-property="${key}"
                    >${this.escapeHtml(String(value || ''))}</textarea>
                `;
                
            default:
                return `
                    <input 
                        id="${fieldId}"
                        class="input property-input" 
                        type="text"
                        data-card-id="${cardId}"
                        data-verb="${verb}"
                        data-property="${key}"
                        value="${this.escapeHtml(String(value || ''))}"
                    />
                `;
        }
    }
    
    renderSwitchCasesEditor(cardData) {
        const switchData = cardData.switch || {};
        const cases = switchData.cases || [];
        const cardId = cardData.id;
        
        let html = `
            <div class="switch-editor">
                <h5 class="title is-6">Switch Cases</h5>
                <div class="switch-cases">
        `;
        
        // æ¸²æŸ“æ¯å€‹ Case (TAFL v1.1.1: åŒ…æ‹¬æ™®é€š cases å’Œ when: "default" çš„ case)
        cases.forEach((caseData, index) => {
            const isDefault = caseData.when === 'default';
            const normalCaseCount = cases.filter((c, i) => i < index && c.when !== 'default').length;
            
            html += `
                <div class="case-item${isDefault ? ' default-case' : ''}" data-case-index="${index}">
                    <div class="level">
                        <div class="level-left">
                            <span class="tag ${isDefault ? 'is-warning' : 'is-info'}">
                                ${isDefault ? 'Default' : `Case ${normalCaseCount + 1}`}
                            </span>
                        </div>
                        <div class="level-right">
                            <div class="field is-grouped">
                                ${!isDefault && index > 0 ? `
                                    <button class="button is-small move-case-up" 
                                            data-card-id="${cardId}" 
                                            data-case-index="${index}">
                                        <span class="icon"><i class="fas fa-arrow-up"></i></span>
                                    </button>
                                ` : ''}
                                ${!isDefault && index < cases.length - 1 && cases[index + 1].when !== 'default' ? `
                                    <button class="button is-small move-case-down" 
                                            data-card-id="${cardId}" 
                                            data-case-index="${index}">
                                        <span class="icon"><i class="fas fa-arrow-down"></i></span>
                                    </button>
                                ` : ''}
                                <button class="button is-small is-danger ${isDefault ? 'remove-default-btn' : 'remove-case-btn'}" 
                                        data-card-id="${cardId}" 
                                        ${!isDefault ? `data-case-index="${index}"` : ''}>
                                    <span class="icon"><i class="fas fa-times"></i></span>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    ${!isDefault ? `
                        <div class="field">
                            <label class="label">When</label>
                            <div class="control">
                                <input class="input property-input case-when" 
                                       type="text"
                                       data-card-id="${cardId}"
                                       data-property="switch.cases.${index}.when"
                                       value="${this.escapeHtml(caseData.when || '')}"
                                       placeholder="Enter condition"
                                />
                            </div>
                        </div>
                    ` : ''}
                    
                    <div class="field">
                        <label class="label">${isDefault ? 'Default Actions' : 'Do'}</label>
                        <div class="has-text-grey-light">
                            <small>${(caseData.do || caseData.then || []).length} steps</small>
                        </div>
                    </div>
                </div>
            `;
        });
        
        // èˆŠç‰ˆ Default case (å‘ä¸‹ç›¸å®¹)
        // å¦‚æœæœ‰èˆŠçš„ default æ¬„ä½ä¸” cases é™£åˆ—ä¸­æ²’æœ‰ when: "default"ï¼Œé¡¯ç¤ºé·ç§»æç¤º
        if (switchData.default && !cases.some(c => c.when === 'default')) {
            html += `
                <div class="notification is-warning is-light">
                    <p>âš ï¸ Legacy default format detected. Click "Add Default" to migrate to TAFL v1.1.1 format.</p>
                </div>
                <div class="case-item default-case">
                    <div class="level">
                        <div class="level-left">
                            <span class="tag is-warning">Default (Legacy)</span>
                        </div>
                        <div class="level-right">
                            <button class="button is-small is-danger remove-default-btn" 
                                    data-card-id="${cardId}">
                                <span class="icon"><i class="fas fa-times"></i></span>
                            </button>
                        </div>
                    </div>
                    <div class="has-text-grey-light">
                        <small>${switchData.default?.length || 0} steps</small>
                    </div>
                </div>
            `;
        }
        
        html += `
                </div>
                
                <div class="field is-grouped">
                    <button class="button is-small is-primary add-case-btn" 
                            data-card-id="${cardId}">
                        <span class="icon"><i class="fas fa-plus"></i></span>
                        <span>Add Case</span>
                    </button>
                    ${!cases.some(c => c.when === 'default') && !switchData.default ? `
                        <button class="button is-small add-default-btn" 
                                data-card-id="${cardId}">
                            <span class="icon"><i class="fas fa-plus"></i></span>
                            <span>Add Default</span>
                        </button>
                    ` : ''}
                </div>
            </div>
        `;
        
        return html;
    }
    
    // ========================================
    // è³‡æ–™æ›´æ–°æ–¹æ³•ï¼ˆæ›´æ–°Storeï¼‰
    // ========================================
    
    updateProperty(cardId, propertyPath, value) {
        // é¡å‹è½‰æ›
        const processedValue = this.processPropertyValue(propertyPath, value);
        
        // é©—è­‰
        if (!this.validateProperty(propertyPath, processedValue)) {
            this.emit('validation:failed', { 
                propertyPath, 
                value: processedValue,
                reason: 'Invalid value' 
            });
            return false;
        }
        
        // Debounced æ›´æ–°
        this.debouncedUpdater.update(`${cardId}-${propertyPath}`, () => {
            taflFlowStore.updateCardProperty(cardId, propertyPath, processedValue);
        });
        
        return true;
    }
    
    updatePropertyImmediate(cardId, propertyPath, value) {
        const processedValue = this.processPropertyValue(propertyPath, value);
        taflFlowStore.updateCardProperty(cardId, propertyPath, processedValue);
    }
    
    addSwitchCase(cardId) {
        taflFlowStore.addSwitchCase(cardId);
    }
    
    removeSwitchCase(cardId, caseIndex) {
        taflFlowStore.removeSwitchCase(cardId, caseIndex);
    }
    
    moveSwitchCase(cardId, fromIndex, direction) {
        const toIndex = direction === 'up' ? fromIndex - 1 : fromIndex + 1;
        taflFlowStore.moveSwitchCase(cardId, fromIndex, toIndex);
    }
    
    toggleDefault(cardId, add = true) {
        const card = taflFlowStore.findCardById(cardId);
        if (!card?.switch) return;
        
        if (add) {
            taflFlowStore.updateCard(cardId, {
                ...card,
                switch: {
                    ...card.switch,
                    default: []
                }
            });
        } else {
            const { default: _, ...switchWithoutDefault } = card.switch;
            taflFlowStore.updateCard(cardId, {
                ...card,
                switch: switchWithoutDefault
            });
        }
    }
    
    // ========================================
    // è¼”åŠ©æ–¹æ³•
    // ========================================
    
    getCardVerb(cardData) {
        console.log('ğŸ¯ [VERB-1] getCardVerb called with:', cardData);
        if (!cardData) {
            console.log('ğŸ¯ [VERB-1a] No cardData, returning null');
            return null;
        }
        
        console.log('ğŸ¯ [VERB-2] Card keys:', Object.keys(cardData));
        console.log('ğŸ¯ [VERB-3] verbDefinitions available:', !!this.verbDefinitions);
        
        // Use verbDefinitions if available (preferred method)
        if (this.verbDefinitions) {
            console.log('ğŸ¯ [VERB-4] Available verb definitions:', Object.keys(this.verbDefinitions));
            const foundVerb = Object.keys(cardData).find(key => {
                const hasVerb = this.verbDefinitions[key] !== undefined;
                console.log('ğŸ¯ [VERB-4a] Checking key:', key, 'is verb:', hasVerb);
                return hasVerb;
            });
            console.log('ğŸ¯ [VERB-5] Found verb from definitions:', foundVerb);
            return foundVerb;
        }
        
        // Fallback: check for known TAFL verbs
        console.log('ğŸ¯ [VERB-6] Using fallback verb check');
        const knownVerbs = [
            'query', 'check', 'create', 'update', 'delete', 
            'if', 'for', 'while', 'switch', 'set', 'get',
            'notify', 'wait', 'retry', 'parallel', 'move',
            'assign', 'call', 'return', 'break', 'continue'
        ];
        const fallbackVerb = Object.keys(cardData).find(key => knownVerbs.includes(key));
        console.log('ğŸ¯ [VERB-7] Found verb from fallback:', fallbackVerb);
        return fallbackVerb;
    }
    
    formatParamName(name) {
        return name
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
    }
    
    getParamHelp(verb, param) {
        const verbDef = this.verbDefinitions?.[verb];
        const paramDef = verbDef?.params?.[param];
        return paramDef?.help || '';
    }
    
    getParamType(verb, param) {
        const verbDef = this.verbDefinitions?.[verb];
        const paramDef = verbDef?.params?.[param];
        return paramDef?.type || 'text';
    }
    
    getParamOptions(verb, param) {
        const verbDef = this.verbDefinitions?.[verb];
        const paramDef = verbDef?.params?.[param];
        return paramDef?.options || [];
    }
    
    processPropertyValue(propertyPath, value) {
        // è™•ç† checkbox
        if (typeof value === 'boolean') {
            return value;
        }
        
        // è™•ç†æ•¸å­—
        if (!isNaN(value) && value !== '') {
            return Number(value);
        }
        
        // è™•ç†ç©ºå­—ä¸²
        if (value === '') {
            return '';
        }
        
        return value;
    }
    
    validateProperty(propertyPath, value) {
        // åŸºæœ¬é©—è­‰
        // å¯ä»¥æ ¹æ“š propertyPath åŠ å…¥æ›´å¤šé©—è­‰è¦å‰‡
        return true;
    }
    
    isInternalProperty(key) {
        return ['then', 'else', 'do', 'cases', 'default'].includes(key);
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // ========================================
    // äº‹ä»¶ç³»çµ±
    // ========================================
    
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }
    
    off(event, callback) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    
    emit(event, data) {
        const callbacks = this.listeners.get(event) || [];
        callbacks.forEach(cb => cb(data));
    }
}

// ========================================
// è¼”åŠ©é¡
// ========================================

class DebouncedUpdater {
    constructor(delay = 300) {
        this.timers = new Map();
        this.delay = delay;
    }
    
    update(key, callback) {
        clearTimeout(this.timers.get(key));
        this.timers.set(key, setTimeout(() => {
            callback();
            this.timers.delete(key);
        }, this.delay));
    }
    
    cancel(key) {
        clearTimeout(this.timers.get(key));
        this.timers.delete(key);
    }
    
    cancelAll() {
        this.timers.forEach(timer => clearTimeout(timer));
        this.timers.clear();
    }
}

// å–®ä¾‹å°å‡º
const taflEditorProperties = new TAFLEditorProperties();
export default taflEditorProperties;
export { TAFLEditorProperties };
