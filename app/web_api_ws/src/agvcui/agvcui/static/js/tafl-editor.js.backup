/**
 * TAFL Editor - Professional Drag & Drop Visual Editor
 * Task Automation Flow Language Visual Editor v3.0
 * Complete rewrite with professional drag & drop experience
 * Now using miniStore for state management
 */

// Import store
import { taflFlowStore } from './tafl-editor/tafl-editor-store.js?v=20250104202000';
// Import notifications module
import taflEditorNotifications, { TAFLEditorNotifications } from './tafl-editor/tafl-editor-notifications.js?v=20250104202000';
// Import API module
import taflAPI from './tafl-editor/tafl-editor-api.js?v=20250104202000';
// Import modals module
import taflModals, { TAFLEditorModals } from './tafl-editor/tafl-editor-modals.js?v=20250104202000';
// Import panels module
import { taflPanels } from './tafl-editor/tafl-panels.js?v=20250104202000';
// Import enhancements module
import TAFLEditorEnhancements, { injectEnhancementsStyles } from './tafl-editor/tafl-editor-enhancements.js?v=20250104202000';
// Import YAML module
import { TAFLEditorYAML } from './tafl-editor/tafl-editor-yaml.js?v=20250104202000';
import taflEditorValidator, { TAFLEditorValidator } from './tafl-editor/tafl-editor-validator.js?v=20250104202000';
// Import Cards module
import taflEditorCards, { TAFLEditorCards } from './tafl-editor/tafl-editor-cards.js?v=20250104202000';
// Import Utils module
import taflEditorUtils, { TAFLEditorUtils } from './tafl-editor/tafl-editor-utils.js?v=20250104202000';
// Import Flow module
import taflEditorFlow, { TAFLEditorFlow } from './tafl-editor/tafl-editor-flow.js?v=20250104202000';
// Import Variables module
import taflEditorVariables, { TAFLEditorVariables } from './tafl-editor/tafl-editor-variables.js?v=20250104202000';
import taflEditorPreload, { TAFLEditorPreload } from './tafl-editor/tafl-editor-preload.js?v=20250104202000';
// Import Rules module
import taflEditorRules, { TAFLEditorRules } from './tafl-editor/tafl-editor-rules.js?v=20250104202000';
// Import Events module  
import taflEditorEvents, { TAFLEditorEvents } from './tafl-editor/tafl-editor-events.js?v=20250104202000';
// Import Properties modules
import taflEditorProperties, { TAFLEditorProperties } from './tafl-editor/tafl-editor-properties.js?v=20250105';
import taflPanelsProperties, { TAFLPanelsProperties } from './tafl-editor/tafl-panels-properties.js?v=20250105';
// Using built-in drag system

class TAFLEditor {
    constructor() {
        // Store manages the flow state now
        // Removed: this.selectedCard - now managed by Store
        this.draggedElement = null;
        this.dragData = null;
        this.yamlModule = null; // YAML module instance
        this.validatorModule = null; // Validator module instance
        this.lastInsertionIndex = undefined;  // Track last drop position to prevent flashing
        this.cardOriginalPositions = new Map();  // è¿½è¹¤å¡ç‰‡çš„åŸå§‹ä½ç½®
        
        // Initialize simplified drag system
        // Using built-in drag system
        
        // Temporary verbDefinitions reference for compatibility
        this.verbDefinitions = {};
        
        // Initialize panels module
        this.panels = taflPanels;
        
        // Initialize enhancements module
        this.enhancements = new TAFLEditorEnhancements(this);
        
        // Initialize notifications module
        this.notificationsModule = new TAFLEditorNotifications(this);
        taflEditorNotifications.editor = this; // Set editor reference for singleton
        
        // Initialize utils module
        this.utilsModule = new TAFLEditorUtils();
        taflEditorUtils.verbDefinitions = this.verbDefinitions; // Share verb definitions
        
        // Initialize flow module
        this.flowModule = new TAFLEditorFlow(this);
        taflEditorFlow.editor = this; // Set editor reference for singleton
        
        // Initialize variables module
        this.variablesModule = new TAFLEditorVariables(this);
        taflEditorVariables.editor = this; // Set editor reference for singleton
        
        // Initialize rules module
        this.rulesModule = new TAFLEditorRules(this);
        taflEditorRules.editor = this; // Set editor reference for singleton
        
        // Initialize properties modules
        this.propertiesModule = new TAFLEditorProperties();
        taflEditorProperties.editor = this; // Set editor reference for singleton
        
        // Properties panel UI will be initialized after DOM is ready
        // Delay initialization to ensure DOM elements exist
        
        // Inject enhancements styles
        injectEnhancementsStyles();
        
        // Subscribe to store events
        this.setupStoreSubscriptions();
        
        this.initializeEditor();
        
        console.log('âœ… TAFL Editor Enhancements initialized - Press ? for keyboard shortcuts');
    }
    
    setupStoreSubscriptions() {
        // Flow changes
        taflFlowStore.on('flow:changed', () => {
            // å¦‚æœæ²’æœ‰å…¶ä»–æ›´å…·é«”çš„äº‹ä»¶è™•ç†ï¼Œä¹Ÿéœ€è¦æ›´æ–°ç•«å¸ƒ
            this.updateCanvas({
                fullRefresh: true,
                skipDuringDrag: false,
                source: 'flow:changed'
            });
            this.updateUI();
            this.yamlModule.refreshYAML();
        });
        
        // Card selection
        taflFlowStore.on('card:selected', (cardId) => {
            this.updateSelectionUI(cardId);
        });
        
        // Card additions
        taflFlowStore.on('card:added', (data) => {
            console.log('ğŸ¨ card:added event handler called with:', data);
            this.updateCanvas({ 
                fullRefresh: true, 
                skipDuringDrag: false,  // æ·»åŠ å¡ç‰‡æ™‚ä¸è¦è·³éæ›´æ–°ï¼
                source: 'card:added' 
            });
            const cardEl = document.querySelector(`[data-card-id="${data.card.id}"]`);
            if (cardEl) {
                console.log('ğŸ¨ Selecting new card:', data.card.id);
                this.selectCard(cardEl);
            } else {
                console.log('ğŸ¨ New card element not found yet:', data.card.id);
            }
        });
        
        // Card updates
        taflFlowStore.on('card:updated', (data) => {
            this.updateCardUI(data.cardId);
        });
        
        // Card deletions
        taflFlowStore.on('card:deleted', (cardId) => {
            console.log('ğŸ¬ Event handler: card:deleted for', cardId);
            this.updateCanvas({ 
                fullRefresh: true, 
                source: 'card:deleted' 
            });
            // Force YAML refresh on delete
            this.yamlModule.refreshYAML();
            this.updateUI();
        });
        
        // Card moves
        taflFlowStore.on('card:moved', (data) => {
            // æª¢æŸ¥æ˜¯å¦éœ€è¦å®Œæ•´æ›´æ–°ï¼ˆå¾åµŒå¥—ç§»åˆ°å¤–å±¤æˆ–åä¹‹ï¼‰
            const needsFullRefresh = this.checkIfStructureChanged(data);
            this.updateCanvas({ 
                fullRefresh: needsFullRefresh,  // çµæ§‹æ”¹è®Šæ™‚éœ€è¦å®Œæ•´æ›´æ–°
                source: 'card:moved' 
            });
        });
        
        // Variables changes
        taflFlowStore.on('variables:changed', (variables) => {
            this.variablesModule.renderVariables();
        });
        
        // Dirty state changes
        taflFlowStore.on('dirty:changed', (isDirty) => {
            this.updateSaveButton(isDirty);
        });
        
        // Flow loaded
        taflFlowStore.on('flow:loaded', (flowData) => {
            console.log('ğŸ”„ flow:loaded event received in tafl-editor.js');
            console.log('ğŸ”„ Event data flow.flow:', flowData?.flow, 'Length:', flowData?.flow?.length);
            console.log('ğŸ”„ Store flow.flow:', taflFlowStore.getFlow()?.flow, 'Length:', taflFlowStore.getFlow()?.flow?.length);
            this.updateCanvas({ 
                fullRefresh: true, 
                preserveScroll: false,  // æ–°è¼‰å…¥ä¸ä¿ç•™æ²å‹•
                source: 'flow:loaded' 
            });
            this.updateUI();
            // Refresh YAML to sync with loaded flow - add delay to ensure flow is fully loaded
            setTimeout(() => {
                this.yamlModule.refreshYAML();
                console.log('ğŸ”„ YAML refreshed after flow load');
            }, 200);
            console.log('ğŸ”„ flow:loaded handler complete');
        });
        
        // Flow cleared (for New Flow action)
        taflFlowStore.on('flow:cleared', () => {
            console.log('ğŸ§¹ flow:cleared event received');
            this.updateCanvas({ 
                fullRefresh: true, 
                preserveScroll: false,
                source: 'flow:cleared' 
            });
            this.updateUI();
            this.yamlModule.refreshYAML();
        });
        
        // Verbs loaded
        taflFlowStore.on('verbs:loaded', (verbs) => {
            this.verbDefinitions = verbs;
        });
        
        // Subscribe to specific flow updates
        taflFlowStore.on('metadata:changed', () => {
            // SimpleTAFLPanels handles metadata UI updates
            // this.refreshMetadataUI();
        });
        
        // Re-render UI when flow changes
        taflFlowStore.on('flow:changed', () => {
            // SimpleTAFLPanels handles all UI updates via store events
            // this.refreshPreloadUI();
            // this.refreshRulesUI();
            // this.refreshSettingsUI();
        });
    }
    
    async initializeEditor() {
        // Register global variables first (must be before module initialization)
        this.registerGlobalVariables();
        
        // Log the initial state to see what's in the store
        console.log('ğŸ” Initial store state on editor init:', taflFlowStore.getFlow());
        
        await this.loadVerbDefinitions();
        this.initializeCards(); // Initialize cards module first
        this.initializeYAML();   // Initialize YAML and preload modules
        this.initializeValidator();
        this.initializeVariables();
        
        // Now initialize events after all modules are created
        this.initializeEvents();
        
        this.setupGlobalEventDelegation();  // æ–°å¢ï¼šå…¨åŸŸäº‹ä»¶å§”æ´¾
        this.initializeDisplayModes();  // Initialize display mode switcher
        this.setupDragAndDrop();
        this.updateUI();
        
        // Log state after initialization
        console.log('ğŸ” Store state after editor init:', taflFlowStore.getFlow());
    }
    
    /**
     * Register global variables for modules that need them
     */
    registerGlobalVariables() {
        window.taflFlowStore = taflFlowStore;
        window.taflModals = taflModals;
        window.taflAPI = taflAPI;
        window.taflPanels = this.panels;
        window.taflEditor = this;
        window.TAFLEditor = TAFLEditor;
    }
    
    initializeYAML() {
        // Create YAML module instance with reference to this editor
        this.yamlModule = new TAFLEditorYAML(this);
        // Initialize YAML editor
        this.yamlModule.initYAMLEditor('yaml-editor-main');
        // Initial YAML refresh
        this.yamlModule.refreshYAML();
        
        // Initialize preload module
        this.preloadModule = new TAFLEditorPreload(this);
        taflEditorPreload.editor = this; // Set editor reference for singleton
    }

    initializeValidator() {
        // Create validator module instance
        this.validatorModule = taflEditorValidator;
        // Initialize validator with editor reference
        this.validatorModule.init(this);
    }
    
    initializeCards() {
        // Create cards module instance
        this.cardsModule = taflEditorCards;
        // Initialize cards module with editor reference and verb definitions
        this.cardsModule.init(this, this.verbDefinitions);
    }
    
    initializeEvents() {
        // Initialize events module after all other modules are created
        this.eventsModule = new TAFLEditorEvents(this);
        taflEditorEvents.editor = this;
        // Now initialize event listeners with all modules available
        this.eventsModule.initEventListeners();
    }
    
    async loadVerbDefinitions() {
        try {
            const verbs = await taflAPI.loadVerbs();
            this.verbDefinitions = verbs;
            taflFlowStore.setVerbDefinitions(verbs);
            
            // Share verb definitions with properties module
            if (this.propertiesModule) {
                this.propertiesModule.verbDefinitions = verbs;
            }
        } catch (error) {
            console.error('Error loading verb definitions:', error);
            this.showNotification(error.message, 'is-danger');
        }
    }
    
    /**
     * Helper method to extract verb from card data in TAFL v1.1 format
     * In TAFL v1.1, the verb is the key, not a property
     */
    getCardVerb(cardData) {
        if (!cardData) return null;
        
        // Exclude known non-verb keys
        const nonVerbKeys = ['id', 'comment', 'skip_if', 'store_as', 'as'];
        
        // Find the verb key (should be one of the TAFL verbs)
        for (const key of Object.keys(cardData)) {
            if (!nonVerbKeys.includes(key) && this.verbDefinitions && this.verbDefinitions[key]) {
                return key;
            }
        }
        
        // Fallback: find any key that's not in the exclusion list
        for (const key of Object.keys(cardData)) {
            if (!nonVerbKeys.includes(key)) {
                return key;
            }
        }
        
        return null;
    }
    
    /**
     * GLOBAL EVENT DELEGATION SYSTEM
     * çµ±ä¸€è™•ç†æ‰€æœ‰å±¤ç´šçš„å¡ç‰‡äº‹ä»¶ï¼Œè§£æ±ºå·¢ç‹€å¡ç‰‡ç„¡æ³•æ“ä½œçš„å•é¡Œ
     */
    setupGlobalEventDelegation() {
        const canvas = document.getElementById('flow-canvas');
        if (!canvas) return;
        
        // 1. çµ±ä¸€é»æ“Šè™•ç†ï¼ˆæ‰€æœ‰å±¤ç´šï¼‰
        canvas.addEventListener('click', (e) => {
            // å¦‚æœæ­£åœ¨æ‹–å‹•ï¼Œå¿½ç•¥é»æ“Šäº‹ä»¶
            if (this.draggedElement || document.body.classList.contains('dragging')) {
                console.log('Ignoring click during drag');
                return;
            }
            
            const card = e.target.closest('.tafl-card');
            
            if (!card) {
                // é»æ“Šç©ºç™½è™•å–æ¶ˆé¸æ“‡
                if (e.target.id === 'flow-canvas' || e.target.classList.contains('canvas-drop-zone')) {
                    this.deselectCard();
                }
                return;
            }
            
            // æª¢æŸ¥æ˜¯å¦é»æ“Šæ§åˆ¶æŒ‰éˆ•
            if (e.target.closest('.card-controls')) {
                e.stopPropagation();
                const btn = e.target.closest('button');
                if (btn?.classList.contains('card-duplicate-btn')) {
                    this.duplicateCard(card.dataset.cardId);
                } else if (btn?.classList.contains('card-delete-btn')) {
                    // Call async deleteCard - no need to await since confirm is synchronous
                    this.deleteCard(card.dataset.cardId);
                }
                return;
            }
            
            // é¸æ“‡å¡ç‰‡
            e.stopPropagation();
            this.selectCard(card);
        });
        
        // 2. çµ±ä¸€æ‹–å‹•é–‹å§‹
        canvas.addEventListener('dragstart', (e) => {
            const card = e.target.closest('.tafl-card');
            console.log('ğŸ”µ Dragstart event fired');
            console.log('  - target:', e.target);
            console.log('  - target tagName:', e.target.tagName);
            console.log('  - target classes:', e.target.className);
            console.log('  - card found:', card);
            console.log('  - isTrusted:', e.isTrusted);
            console.log('  - bubbles:', e.bubbles);
            console.log('  - cancelable:', e.cancelable);
            console.log('  - dataTransfer:', e.dataTransfer);
            console.log('  - currentTarget:', e.currentTarget);
            console.log('  - eventPhase:', e.eventPhase);
            console.log('  - defaultPrevented:', e.defaultPrevented);
            
            // æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–äº‹ä»¶ç›£è½å™¨
            if (typeof getEventListeners !== 'undefined') {
                const listeners = getEventListeners(e.target);
                console.log('  - Event listeners on target:', listeners);
            }
            
            if (!card) {
                console.log('âŒ No card found for dragstart');
                return;
            }
            
            if (!card.draggable) {
                console.log('âŒ Card is not draggable:', card);
                console.log('  - card.draggable attribute:', card.getAttribute('draggable'));
                return;
            }
            
            console.log('ğŸ“ Card info:');
            console.log('  - cardId:', card.dataset.cardId);
            console.log('  - parent:', card.parentElement);
            console.log('  - parent tagName:', card.parentElement?.tagName);
            console.log('  - parent classes:', card.parentElement?.className);
            console.log('  - classList:', card.classList.toString());
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ CSS é˜»æ­¢æ‹–å‹•
            const computedStyle = window.getComputedStyle(card);
            console.log('  - computed userSelect:', computedStyle.userSelect);
            console.log('  - computed pointerEvents:', computedStyle.pointerEvents);
            console.log('  - computed cursor:', computedStyle.cursor);
            console.log('  - computed touchAction:', computedStyle.touchAction);
            console.log('  - computed webkitUserDrag:', computedStyle.webkitUserDrag);
            
            // æª¢æŸ¥çˆ¶å…ƒç´ æ¨£å¼
            const parentStyle = card.parentElement ? window.getComputedStyle(card.parentElement) : null;
            if (parentStyle) {
                console.log('  - parent userSelect:', parentStyle.userSelect);
                console.log('  - parent pointerEvents:', parentStyle.pointerEvents);
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ±è¥¿é˜»æ­¢æ‹–å‹•
            const isDefaultPrevented = e.defaultPrevented;
            console.log('  - defaultPrevented before our handling:', isDefaultPrevented);
            
            // ä¸è¦ stopPropagation - è®“äº‹ä»¶æ­£å¸¸å†’æ³¡
            // e.stopPropagation();
            
            // ç«‹å³è¨­ç½®æ‹–å‹•æ•¸æ“šï¼Œç¢ºä¿ dragover å¯ä»¥è¨ªå•
            this.draggedElement = card;
            
            // è¨˜éŒ„åŸå§‹ä½ç½®ï¼ˆæ˜¯å¦åœ¨åµŒå¥—ä¸­ï¼‰
            const cardId = card.dataset.cardId;
            const isNested = card.closest('.nested-cards') !== null;
            this.cardOriginalPositions.set(cardId, { isNested });
            console.log(`ğŸ“Œ Recording original position for card ${cardId}: nested=${isNested}`);
            
            this.dragData = {
                type: 'card',
                cardId: cardId
            };
            
            console.log('ğŸ“¦ Setting dataTransfer:');
            console.log('  - effectAllowed: move');
            console.log('  - dropEffect: move');
            
            // è¨­ç½® dataTransfer
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.dropEffect = 'move';
            
            // è¨­å®šæ‹–å‹•æ™‚çš„è¦–è¦ºæ•ˆæœ - ç›´æ¥ä½¿ç”¨åŸå§‹å…ƒç´ 
            // é¿å…å‰µå»ºè¤‡è£½å…ƒç´ å¯èƒ½å°è‡´çš„å•é¡Œ
            if (e.dataTransfer.setDragImage) {
                console.log('  - Setting drag image');
                console.log('  - offsetX:', e.offsetX);
                console.log('  - offsetY:', e.offsetY);
                e.dataTransfer.setDragImage(card, e.offsetX, e.offsetY);
            }
            
            try {
                e.dataTransfer.setData('text/plain', JSON.stringify(this.dragData));
                console.log('  - Data set successfully');
            } catch (err) {
                console.error('âŒ Error setting drag data:', err);
            }
            
            card.classList.add('dragging');
            document.body.classList.add('dragging'); // è¨­ç½®å…¨åŸŸæ‹–å‹•ç‹€æ…‹
            
            // ä¸éœ€è¦é¡å¤–çš„ placeholderï¼Œè®“åŸå¡ç‰‡ä¿æŒ opacity: 0.5 å³å¯
            
            // æª¢æŸ¥å¡ç‰‡æ˜¯å¦ä»ç„¶å¯æ‹–å‹•
            setTimeout(() => {
                if (!card.draggable) {
                    console.log('âš ï¸ Card became undraggable after dragstart!');
                }
                if (!document.body.contains(card)) {
                    console.log('âš ï¸ Card was removed from DOM after dragstart!');
                }
                const stillDragging = card.classList.contains('dragging');
                console.log('  - Card still has dragging class after 10ms:', stillDragging);
            }, 10);
            
            console.log('âœ… Drag start completed');
            console.log('  - draggedElement set:', !!this.draggedElement);
            console.log('  - dragData set:', this.dragData);
            console.log('  - Event propagation stopping?', e.cancelBubble);
            
            // æ·»åŠ ç›£è½å™¨ä¾†è¿½è¸ªä½•æ™‚è§¸ç™¼ dragend
            let dragEventCount = 0;
            const dragHandler = (e) => {
                dragEventCount++;
                if (dragEventCount === 1 || dragEventCount % 50 === 0) {
                    console.log(`ğŸŸ¡ Drag event #${dragEventCount} (during drag)`);
                    console.log('  - clientX:', e.clientX);
                    console.log('  - clientY:', e.clientY);
                }
            };
            window.addEventListener('drag', dragHandler);
            this.onDrag = dragHandler;
            
            // ç›£è½å„ç¨®å¯èƒ½å°è‡´ drag çµæŸçš„äº‹ä»¶
            const mouseUpHandler = (e) => {
                console.log('ğŸŸ  MouseUp event during drag!');
                console.log('  - target:', e.target);
                console.log('  - button:', e.button);
            };
            window.addEventListener('mouseup', mouseUpHandler, { once: true });
            
            // ç›£è½ ESC éµ
            const keyHandler = (e) => {
                if (e.key === 'Escape') {
                    console.log('ğŸŸ  ESC key pressed during drag!');
                }
            };
            window.addEventListener('keydown', keyHandler);
            
            // ç›£è½ document ä¸Šçš„ dragend äº‹ä»¶ï¼Œä»¥é˜²åœ¨ canvas å¤–çµæŸ
            document.addEventListener('dragend', this.onDocDragEnd = (e) => {
                console.log('ğŸ”´ Document dragend event fired');
                console.log('  - target:', e.target);
                console.log('  - outside canvas?', !canvas.contains(e.target));
                
                // æ¸…ç†äº‹ä»¶ç›£è½å™¨
                window.removeEventListener('mouseup', mouseUpHandler);
                window.removeEventListener('keydown', keyHandler);
            }, { once: true });
        }, false);
        
        // 3. çµ±ä¸€æ‹–å‹•çµæŸ
        canvas.addEventListener('dragend', (e) => {
            console.log('ğŸ”´ Canvas dragend event fired');
            console.log('  - dropEffect:', e.dataTransfer.dropEffect);
            console.log('  - effectAllowed:', e.dataTransfer.effectAllowed);
            console.log('  - isTrusted:', e.isTrusted);
            console.log('  - target:', e.target);
            console.log('  - target tagName:', e.target.tagName);
            console.log('  - target classes:', e.target.className);
            console.log('  - currentTarget:', e.currentTarget);
            console.log('  - eventPhase:', e.eventPhase);
            console.log('  - clientX:', e.clientX);
            console.log('  - clientY:', e.clientY);
            console.log('  - screenX:', e.screenX);
            console.log('  - screenY:', e.screenY);
            
            // ç§»é™¤ drag äº‹ä»¶ç›£è½å™¨
            if (this.onDrag) {
                window.removeEventListener('drag', this.onDrag);
                console.log('  - Removed drag event listener');
            }
            
            // ç§»é™¤ document dragend ç›£è½å™¨
            if (this.onDocDragEnd) {
                document.removeEventListener('dragend', this.onDocDragEnd);
                console.log('  - Removed document dragend listener');
            }
            
            // æª¢æŸ¥æ‹–å‹•æ˜¯å¦çœŸçš„æˆåŠŸ
            console.log('  - Was drag successful?', e.dataTransfer.dropEffect !== 'none');
            
            const card = e.target.closest('.tafl-card');
            if (!card) {
                console.log('âŒ No card found for dragend');
                return;
            }
            
            console.log('ğŸ“ Dragend card info:');
            console.log('  - cardId:', card.dataset.cardId);
            console.log('  - was dragging:', card.classList.contains('dragging'));
            console.log('  - had draggedElement:', this.draggedElement === card);
            
            card.classList.remove('dragging');
            document.body.classList.remove('dragging'); // ç§»é™¤å…¨åŸŸæ‹–å‹•ç‹€æ…‹
            
            // æ¸…ç†æ‰€æœ‰ placeholder å’ŒæŒ‡ç¤ºå™¨
            this.hideDropIndicators();
            document.querySelectorAll('.tafl-card-placeholder').forEach(p => p.remove());
            
            // ç«‹å³æ¸…ç†æ‹–æ›³ç‹€æ…‹ - ä¸éœ€è¦å»¶é²ï¼
            this.draggedElement = null;
            this.dragData = null;
            console.log('  - Cleared drag data immediately');
            
            console.log('âœ… Dragend completed');
        }, false);
        
        // 4. çµ±ä¸€æ‹–å‹•ç¶“é
        let dragoverCount = 0;
        canvas.addEventListener('dragover', (e) => {
            dragoverCount++;
            if (dragoverCount === 1 || dragoverCount % 10 === 0) {
                console.log(`ğŸŸ¢ Dragover event #${dragoverCount}`);
                console.log('  - has dragData:', !!this.dragData);
                console.log('  - target:', e.target.tagName, e.target.className);
            }
            
            // å§‹çµ‚é˜»æ­¢é»˜èªè¡Œç‚ºï¼Œå…è¨± drop
            e.preventDefault();
            
            // æ ¹æ“šæ‹–å‹•é¡å‹è¨­ç½®æ­£ç¢ºçš„ dropEffect
            if (this.dragData) {
                e.dataTransfer.dropEffect = this.dragData.type === 'verb' ? 'copy' : 'move';
            } else {
                e.dataTransfer.dropEffect = 'move';
            }
            
            // å¦‚æœæ²’æœ‰æ‹–å‹•æ•¸æ“šï¼Œä¸æ›´æ–°è¦–è¦ºæ•ˆæœ
            if (!this.dragData) {
                console.log('âš ï¸ Dragover without dragData');
                return;
            }
            
            // è™•ç†å·¢ç‹€ drop zone çš„ hover æ•ˆæœ
            const nestedDropZone = e.target.closest('.nested-drop-zone');
            if (nestedDropZone) {
                nestedDropZone.classList.add('drag-over');
            }
            
            this.updateUnifiedDropIndicator(e);
        }, false);
        
        // 4.5. çµ±ä¸€æ‹–å‹•é›¢é–‹
        canvas.addEventListener('dragleave', (e) => {
            // è™•ç†å·¢ç‹€ drop zone çš„ hover ç§»é™¤
            const nestedDropZone = e.target.closest('.nested-drop-zone');
            if (nestedDropZone && !nestedDropZone.contains(e.relatedTarget)) {
                nestedDropZone.classList.remove('drag-over');
            }
        }, false);
        
        // 5. çµ±ä¸€æ”¾ç½®è™•ç†
        canvas.addEventListener('drop', (e) => {
            console.log('ğŸ“ Drop event triggered, dragData:', this.dragData);
            
            // ç¢ºä¿æœ‰æ‹–å‹•æ•¸æ“š
            // æ³¨æ„ï¼šå¾ Verbs æ‹–å‹•æ™‚ï¼ŒdraggedElement æ˜¯ nullï¼Œä½† dragData å­˜åœ¨
            if (!this.dragData) {
                console.log('Drop event but no drag data');
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            console.log('ğŸ“ Drop event at:', e.clientX, e.clientY, 'dragData type:', this.dragData.type);
            
            // å„ªå…ˆä½¿ç”¨ placeholder çš„ä½ç½®
            const placeholder = document.querySelector('.tafl-card-placeholder');
            let position;
            
            if (placeholder) {
                // å¦‚æœæœ‰ placeholderï¼Œä½¿ç”¨å®ƒçš„ä½ç½®
                const parent = placeholder.parentElement;
                const children = Array.from(parent.children).filter(child => 
                    !child.classList.contains('tafl-card-placeholder')
                );
                
                // è¨ˆç®—å¯¦éš›çš„æ’å…¥ç´¢å¼•ï¼ˆæ’é™¤ placeholder æœ¬èº«ï¼‰
                let index = 0;
                for (let i = 0; i < parent.children.length; i++) {
                    if (parent.children[i] === placeholder) {
                        break;
                    }
                    if (!parent.children[i].classList.contains('tafl-card-placeholder')) {
                        index++;
                    }
                }
                
                // åˆ¤æ–·æ˜¯å¦åœ¨å·¢ç‹€çµæ§‹ä¸­
                const nestedContainer = placeholder.closest('.nested-cards');
                if (nestedContainer) {
                    const parentCard = nestedContainer.closest('.tafl-card');
                    const branchType = nestedContainer.dataset.branch;
                    position = {
                        nested: {
                            parentCardId: parentCard.dataset.cardId,
                            branchType: branchType
                        },
                        index: index
                    };
                } else {
                    position = {
                        nested: null,
                        index: index
                    };
                }
                console.log('âœ… Using placeholder position:', position);
                
                // ç§»é™¤ placeholder
                placeholder.remove();
            } else {
                // æ²’æœ‰ placeholder æ™‚çš„å‚™ç”¨é‚è¼¯
                const dropZone = e.target.closest('.drop-zone, .nested-drop-zone, .canvas-drop-zone');
                if (dropZone) {
                    position = this.getDropZonePosition(dropZone, e);
                    console.log('Drop zone detected:', dropZone, 'position:', position);
                } else {
                    position = this.calculateUnifiedDropPosition(e);
                    console.log('Calculated position (no placeholder):', position);
                }
            }
            
            // å…ˆæ¸…é™¤æ‹–æ›³ç‹€æ…‹ï¼Œç¢ºä¿ card:added äº‹ä»¶ä¸æœƒè¢«è·³é
            document.body.classList.remove('dragging');
            this.draggedElement = null;
            
            if (position) {
                console.log('ğŸ’§ Handling drop at position:', position);
                this.handleUnifiedDrop(position);
            } else {
                console.log('âš ï¸ Could not determine drop position');
            }
            
            // æ¸…ç†æ‰€æœ‰ placeholder
            document.querySelectorAll('.tafl-card-placeholder').forEach(p => p.remove());
            this.hideDropIndicators();
            this.hideAllDropZones();
            
            // ç«‹å³æ¸…ç©º dragData é¿å…é‡è¤‡è™•ç†
            this.dragData = null;
            this.draggedElement = null;
        }, false);
    }
    
    /**
     * ç²å– drop zone çš„ä½ç½®ä¿¡æ¯
     */
    getDropZonePosition(dropZone, event) {
        // æª¢æŸ¥æ˜¯å¦æ˜¯åµŒå¥— drop zone (ä½¿ç”¨æ­£ç¢ºçš„ class)
        const branch = dropZone.closest('.nested-cards');
        if (branch) {
            const branchName = branch.dataset.branch;
            const parentCard = branch.closest('.tafl-card');
            if (parentCard) {
                const parentId = parentCard.dataset.cardId;
                
                // æ‰¾åˆ°è©² branch å…§çš„ç¾æœ‰å¡ç‰‡æ•¸é‡ä¾†æ±ºå®š index
                const existingCards = branch.querySelectorAll('.tafl-card');
                const index = existingCards.length;
                
                return {
                    nested: {
                        parentCardId: parentId,  // çµ±ä¸€ä½¿ç”¨ parentCardId
                        branchType: branchName    // çµ±ä¸€ä½¿ç”¨ branchType
                    },
                    index: index
                };
            }
        }
        
        // ä¸»ç•«å¸ƒ drop zone - ä½¿ç”¨çµ±ä¸€çš„è¨ˆç®—é‚è¼¯
        const canvasDropZone = document.getElementById('canvas-drop-zone');
        const cards = Array.from(canvasDropZone.querySelectorAll(':scope > .tafl-card'));
        
        // å¦‚æœæœ‰ eventï¼Œä½¿ç”¨çµ±ä¸€çš„ä½ç½®è¨ˆç®—æ–¹æ³•
        if (event) {
            const result = this.calculateIndexFromPosition(event, cards);
            
            // è™•ç†æ­»å€æƒ…æ³
            if (result && typeof result === 'object' && result.isDeadZone) {
                console.log('[getDropZonePosition] Dead zone detected');
                return {
                    nested: null,
                    index: result.index,
                    isDeadZone: true
                };
            }
            
            console.log('[getDropZonePosition] Calculated index:', result);
            return {
                nested: null,
                index: result
            };
        }
        
        // æ²’æœ‰ event æ™‚ï¼Œé è¨­æ”¾åœ¨æœ€å¾Œ
        return {
            nested: null,
            index: cards.length
        };
    }
    
    /**
     * PROFESSIONAL DRAG & DROP SYSTEM
     * Complete rewrite based on successful patterns from linear flow designer
     */
    setupDragAndDrop() {
        const canvas = document.getElementById('flow-canvas');
        
        if (!canvas) {
            console.error('Canvas element not found!');
            return;
        }
        
        // Set up toolbox drag sources
        this.setupToolboxDragSources();
        
        // Set up canvas as drop target
        this.setupCanvasDropTarget(canvas);
        
        // Initialize drop zones
        this.createInitialDropZone();
        
        // Make sure existing cards are draggable
        this.refreshCardDragHandlers();
        
        console.log('âœ… Drag and drop initialized');
    }
    
    setupToolboxDragSources() {
        // Make verb items draggable
        document.querySelectorAll('.verb-item').forEach(item => {
            item.draggable = true;
            
            // Visual feedback that item is draggable
            item.style.cursor = 'move';
            item.title = 'Drag to add to flow';
            
            item.addEventListener('dragstart', (e) => {
                e.stopPropagation();
                document.body.classList.add('dragging');
                
                const verb = item.dataset.verb;
                // Always set dragData as primary data storage
                this.dragData = {
                    type: 'verb',
                    verb: verb,
                    source: 'toolbox'
                };
                
                // Try to set data for drop detection (may fail in some browsers)
                try {
                    e.dataTransfer.setData('application/json', JSON.stringify(this.dragData));
                    e.dataTransfer.setData('text/plain', verb); // Fallback
                } catch (err) {
                    console.warn('Could not set dataTransfer data:', err);
                }
                e.dataTransfer.effectAllowed = 'copy';
                
                // Visual feedback
                item.classList.add('is-dragging');
                this.showAllDropZones();
                
                console.log('ğŸ¯ Started dragging verb:', verb);
            });
            
            item.addEventListener('dragend', (e) => {
                item.classList.remove('is-dragging');
                document.body.classList.remove('dragging');
                this.hideAllDropZones();
                
                // æ¸…ç†æ‰€æœ‰ placeholder
                document.querySelectorAll('.tafl-card-placeholder').forEach(p => p.remove());
                this.hideDropIndicators();
                
                // Don't clear dragData immediately, let drop handler use it first
                setTimeout(() => {
                    this.dragData = null;
                }, 100);
                
                console.log('ğŸ¯ Ended dragging');
            });
        });
    }
    
    setupCanvasDropTarget(canvas) {
        // Canvas-level drag events
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            
            // Always update drop indicators during dragover
            this.updateUnifiedDropIndicator(e);
            
            const dragData = this.getDragData(e) || this.dragData;
            if (dragData) {
                e.dataTransfer.dropEffect = dragData.source === 'toolbox' ? 'copy' : 'move';
            }
        });
        
        canvas.addEventListener('dragleave', (e) => {
            // Only hide if truly leaving canvas
            if (!canvas.contains(e.relatedTarget)) {
                this.hideDropIndicators();
            }
        });
        
        // ç§»é™¤é‡è¤‡çš„ drop ç›£è½å™¨ï¼Œå·²ç¶“åœ¨ setupUnifiedDragDrop ä¸­è™•ç†
    }
    
    getDragData(e) {
        // During drag, we can't always read dataTransfer, so use stored dragData
        if (this.dragData) {
            return this.dragData;
        }
        
        try {
            const jsonData = e.dataTransfer.getData('application/json');
            if (jsonData) {
                return JSON.parse(jsonData);
            }
        } catch (err) {
            // Fallback to plain text
            const verb = e.dataTransfer.getData('text/plain');
            if (verb) {
                return { type: 'verb', verb: verb, source: 'toolbox' };
            }
        }
        return null;
    }
    
    handleCanvasDrop(e) {
        // æª¢æŸ¥æ˜¯å¦å·²ç¶“è¢« drop zone è™•ç†é
        if (e.defaultPrevented) {
            return;
        }
        
        const dragData = this.getDragData(e);
        if (!dragData) {
            return;
        }
        
        console.log('ğŸ¯ Drop on canvas:', dragData);
        
        this.hideAllDropZones();
        this.hideDropIndicators();
        
        if (dragData.type === 'verb' && dragData.source === 'toolbox') {
            // Adding new card from toolbox
            const dropPosition = this.calculateUnifiedDropPosition(e);
            this.addCardAtPosition(dragData.verb, dropPosition);
        } else if (dragData.type === 'card') {
            // Moving existing card
            const dropPosition = this.calculateUnifiedDropPosition(e);
            this.moveCardToPosition(dragData.cardId, dropPosition);
        }
    }
    
    calculateDropPosition(e) {
        const dropZone = document.getElementById('canvas-drop-zone');
        if (!dropZone) {
            // å¦‚æœ drop zone ä¸å­˜åœ¨ï¼Œè¿”å›é»˜èªä½ç½®
            return { index: 0, nested: null };
        }
        
        // Get all cards including the dragging one to calculate correct original index
        const allCards = Array.from(dropZone.querySelectorAll('.tafl-card'));
        const draggingCard = dropZone.querySelector('.tafl-card.dragging');
        const draggingCardIndex = draggingCard ? allCards.indexOf(draggingCard) : -1;
        
        // Get cards excluding the dragging one for position calculation
        const cards = Array.from(dropZone.querySelectorAll('.tafl-card:not(.dragging)'));
        
        if (cards.length === 0 && !draggingCard) {
            return { index: 0, nested: null };
        }
        
        const mouseY = e.clientY;
        let targetIndex = cards.length;
        
        // Find insertion position based on non-dragging cards
        for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            const rect = card.getBoundingClientRect();
            const cardMiddle = rect.top + rect.height / 2;
            
            if (mouseY < cardMiddle) {
                targetIndex = i;
                break;
            }
        }
        
        // Adjust index if dragging a card from before the target position
        // This is necessary because the dragging card will be removed first
        // and then inserted, which changes the indices
        if (draggingCard && draggingCardIndex !== -1 && draggingCardIndex < targetIndex) {
            // The target index should account for the fact that the dragging card
            // will be removed, which shifts all subsequent indices down by 1
            // But since we already excluded the dragging card from 'cards',
            // the targetIndex is already correct for the final position
            // No adjustment needed here
        }
        
        // Check for nested drop zones
        const nestedArea = this.getNestedDropTarget(e.target);
        if (nestedArea) {
            const parentCard = nestedArea.closest('.tafl-card');
            const parentCardId = parentCard?.dataset.cardId;
            const branchType = this.getBranchType(nestedArea);
            
            if (parentCardId && branchType) {
                return {
                    nested: {
                        parentCardId: parentCardId,
                        branchType: branchType
                    }
                };
            }
        }
        
        console.log('ğŸ“ Drop position calculated:', {
            targetIndex,
            draggingCardIndex,
            totalCards: allCards.length,
            mouseY
        });
        
        return { index: targetIndex, nested: null };
    }
    
    /**
     * UNIFIED DROP POSITION CALCULATION
     * çµ±ä¸€è¨ˆç®—æ‰€æœ‰å±¤ç´šçš„æ”¾ç½®ä½ç½®
     */
    calculateUnifiedDropPosition(e) {
        // 1. æª¢æŸ¥æ˜¯å¦åœ¨ç©ºçš„å·¢ç‹€æ”¾ç½®å€
        const emptyNested = e.target.closest('.nested-drop-zone.empty-zone');
        if (emptyNested) {
            const parentCard = emptyNested.closest('.tafl-card');
            const branch = emptyNested.dataset.branch;
            
            if (parentCard && branch) {
                return {
                    nested: {
                        parentCardId: parentCard.dataset.cardId,
                        branchType: branch
                    },
                    index: 0
                };
            }
        }
        
        // 2. æª¢æŸ¥æ˜¯å¦åœ¨å·¢ç‹€å¡ç‰‡ä¹‹é–“
        const nestedCards = e.target.closest('.nested-cards');
        if (nestedCards) {
            const parentCard = nestedCards.closest('.tafl-card');
            const branch = nestedCards.dataset.branch;
            
            if (parentCard && branch) {
                const cards = Array.from(nestedCards.querySelectorAll(':scope > .tafl-card'));
                const index = this.calculateIndexFromPosition(e, cards);
                
                return {
                    nested: {
                        parentCardId: parentCard.dataset.cardId,
                        branchType: branch
                    },
                    index: index
                };
            }
        }
        
        // 3. ä¸»æµç¨‹ä½ç½®
        const dropZone = document.getElementById('canvas-drop-zone');
        if (!dropZone) {
            // å¦‚æœ drop zone ä¸å­˜åœ¨ï¼Œè¿”å›é»˜èªä½ç½®
            return {
                nested: null,
                index: 0
            };
        }
        const mainCards = Array.from(dropZone.querySelectorAll(':scope > .tafl-card'));
        const result = this.calculateIndexFromPosition(e, mainCards);
        
        // è™•ç†æ­»å€æƒ…æ³
        if (result && typeof result === 'object' && result.isDeadZone) {
            return {
                nested: null,
                index: result.index,
                isDeadZone: true
            };
        }
        
        return {
            nested: null,
            index: result
        };
    }
    
    /**
     * å‰µå»º Placeholder å…ƒç´ 
     */
    createPlaceholder() {
        const placeholder = document.createElement('div');
        placeholder.className = 'tafl-card-placeholder';
        placeholder.dataset.placeholder = 'true';
        
        // å¦‚æœæœ‰æ‹–å‹•å…ƒç´ ï¼ŒåŒ¹é…å…¶é«˜åº¦
        if (this.draggedElement) {
            const height = this.draggedElement.offsetHeight;
            placeholder.style.minHeight = `${height}px`;
        }
        
        return placeholder;
    }
    
    /**
     * è¼”åŠ©æ–¹æ³•ï¼šæ ¹æ“šæ»‘é¼ ä½ç½®è¨ˆç®—æ’å…¥ç´¢å¼•ï¼ˆ30% è¦å‰‡ï¼‰
     */
    calculateIndexFromPosition(e, cards) {
        const mouseY = e.clientY;
        
        console.log('ğŸ“ calculateIndexFromPosition (30% threshold):');
        console.log('  - mouseY:', mouseY);
        console.log('  - cards count:', cards.length);
        
        // å¦‚æœæ²’æœ‰å¡ç‰‡ï¼Œè¿”å› 0
        if (cards.length === 0) {
            console.log('  - No cards, returning 0');
            return 0;
        }
        
        // ç²å–æ­£åœ¨æ‹–å‹•çš„å¡ç‰‡ ID
        const draggingCardId = this.dragData?.cardId || this.draggedElement?.dataset?.cardId;
        
        // ä½¿ç”¨ 30% è¦å‰‡é€²è¡Œæ›´éˆæ•çš„æª¢æ¸¬
        for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            
            // è·³é placeholder å’Œæ­£åœ¨æ‹–å‹•çš„å¡ç‰‡
            if (card.dataset.placeholder === 'true') continue;
            if (draggingCardId && card.dataset.cardId === draggingCardId) continue;
            
            const rect = card.getBoundingClientRect();
            const threshold = rect.top + rect.height * 0.3; // 30% é–¾å€¼
            
            console.log(`  - Card ${i}: top=${rect.top}, height=${rect.height}, threshold=${threshold}`);
            
            if (mouseY < threshold) {
                console.log(`  - Mouse is above 30% of card ${i}, target index = ${i}`);
                return i;
            }
        }
        
        // å¦‚æœæ²’æœ‰åœ¨ä»»ä½•å¡ç‰‡ 30% ä¹‹å‰ï¼Œå‰‡æ”¾åœ¨æœ€å¾Œ
        console.log('  - Mouse is below all cards, target index = end');
        return cards.length;
    }
    
    /**
     * UNIFIED DROP HANDLER
     * çµ±ä¸€è™•ç†æ‰€æœ‰æ”¾ç½®æ“ä½œï¼ˆæ–°å¢å’Œç§»å‹•ï¼‰
     */
    handleUnifiedDrop(position) {
        // ä¿å­˜ dragData å› ç‚ºå¯èƒ½æœƒè¢«æ¸…ç©º
        const dragDataCopy = { ...this.dragData };
        
        if (!dragDataCopy || !dragDataCopy.type) {
            console.warn('No drag data available for drop');
            return;
        }
        
        if (dragDataCopy.type === 'verb') {
            // æ–°å¢å¡ç‰‡
            this.addCardAtPosition(dragDataCopy.verb, position);
        } else if (dragDataCopy.type === 'card') {
            // ç§»å‹•ç¾æœ‰å¡ç‰‡ï¼ˆä½¿ç”¨ Store çš„çµ±ä¸€é‚è¼¯ï¼‰
            console.log('ğŸš€ Moving card:', dragDataCopy.cardId, 'to position:', position);
            
            // åœ¨ç§»å‹•å‰æ¸…ç†æ‹–æ›³ç‹€æ…‹ï¼Œç¢ºä¿æ›´æ–°ä¸æœƒè¢«è·³é
            this.draggedElement = null;
            this.dragData = null;
            document.body.classList.remove('dragging');
            
            taflFlowStore.moveCard(dragDataCopy.cardId, position);
            // ä¸å†æ‰‹å‹•èª¿ç”¨ refreshCanvasï¼Œç”± card:moved äº‹ä»¶è™•ç†
            
            // é‡æ–°é¸æ“‡ç§»å‹•çš„å¡ç‰‡
            setTimeout(() => {
                const movedCard = document.querySelector(`[data-card-id="${dragDataCopy.cardId}"]`);
                if (movedCard) {
                    movedCard.classList.add('just-moved');
                    setTimeout(() => movedCard.classList.remove('just-moved'), 500);
                    this.selectCard(movedCard);
                }
            }, 100);
            
            this.markDirty();
            this.showNotification('Card moved successfully', 'is-success');
        }
    }
    
    /**
     * æ›´æ–° Placeholder ä½ç½®
     */
    updatePlaceholder(e) {
        // ç§»é™¤ç¾æœ‰çš„ placeholder (ä½†ä¿ç•™ original-position-placeholder)
        const existingPlaceholder = document.querySelector('.tafl-card-placeholder:not(.original-position-placeholder)');
        if (existingPlaceholder) {
            existingPlaceholder.remove();
        }
        
        // è¨ˆç®—æ–°ä½ç½®
        const position = this.calculateUnifiedDropPosition(e);
        if (!position) return;
        
        // å‰µå»ºæ–°çš„ placeholder
        const placeholder = this.createPlaceholder();
        
        // æ ¹æ“šä½ç½®é¡å‹æ’å…¥ placeholder
        if (position.nested) {
            // å·¢ç‹€çµæ§‹ä¸­
            const parentCard = document.querySelector(`[data-card-id="${position.nested.parentCardId}"]`);
            const nestedContainer = parentCard?.querySelector(`.nested-cards[data-branch="${position.nested.branchType}"]`);
            
            if (nestedContainer) {
                const nestedCards = Array.from(nestedContainer.querySelectorAll(':scope > .tafl-card'));
                if (position.index >= nestedCards.length) {
                    nestedContainer.appendChild(placeholder);
                } else {
                    nestedCards[position.index].insertAdjacentElement('beforebegin', placeholder);
                }
            }
        } else {
            // ä¸»æµç¨‹ä¸­
            const dropZone = document.getElementById('canvas-drop-zone');
            if (!dropZone) return;
            
            const mainCards = Array.from(dropZone.querySelectorAll(':scope > .tafl-card:not(.tafl-card-placeholder)'));
            if (position.index >= mainCards.length) {
                dropZone.appendChild(placeholder);
            } else if (position.index === 0 && mainCards.length > 0) {
                mainCards[0].insertAdjacentElement('beforebegin', placeholder);
            } else if (position.index > 0 && position.index < mainCards.length) {
                mainCards[position.index].insertAdjacentElement('beforebegin', placeholder);
            } else {
                dropZone.appendChild(placeholder);
            }
        }
        
        // è¨˜éŒ„ä½ç½®
        this.lastPlaceholderPosition = position;
    }
    
    /**
     * UNIFIED DROP INDICATOR UPDATE (å·²æ£„ç”¨ï¼Œæ”¹ç”¨ updatePlaceholder)
     * ä¿ç•™æ­¤å‡½æ•¸ä»¥ç¶­æŒç›¸å®¹æ€§ï¼Œä½†æ”¹ç‚ºèª¿ç”¨ updatePlaceholder
     */
    updateUnifiedDropIndicator(e) {
        // ä½¿ç”¨åŸä¾†çš„ insertion-line ç³»çµ±ï¼ˆæ°´å¹³å¼•å°ç·šï¼‰
        this.updateDropIndicators(e);
        return;
    }
    
    showAllDropZones() {
        const canvas = document.getElementById('flow-canvas');
        const dropZones = canvas.querySelectorAll('.drop-zone');
        
        dropZones.forEach(zone => {
            zone.classList.add('visible');
        });
        
        // Show main drop zone if no cards
        const flow = taflFlowStore.getFlow();
        if (flow.flow.length === 0) {
            const mainDropZone = document.getElementById('canvas-drop-zone');
            mainDropZone.classList.add('drag-active');
        }
        
        // Show nested drop zones
        canvas.querySelectorAll('.nested-drop-zone').forEach(zone => {
            zone.classList.add('visible');
        });
    }
    
    hideAllDropZones() {
        const canvas = document.getElementById('flow-canvas');
        
        canvas.querySelectorAll('.drop-zone, .nested-drop-zone').forEach(zone => {
            zone.classList.remove('visible', 'drag-over');
        });
        
        const mainDropZone = document.getElementById('canvas-drop-zone');
        if (mainDropZone) {
            mainDropZone.classList.remove('drag-active', 'drag-over');
        }
    }
    
    // Generate unique ID for cards without IDs
    generateId() {
        // Delegate to utils module
        return this.utilsModule.generateId();
    }
    
    updateDropIndicators(e) {
        const dropZone = document.getElementById('canvas-drop-zone');
        if (!dropZone) {
            // å¦‚æœ drop zone ä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›
            return;
        }
        const cards = Array.from(dropZone.querySelectorAll('.tafl-card:not(.dragging)'));
        
        // If no cards, show drop zone in canvas
        if (cards.length === 0) {
            // dropZone å·²ç¶“åœ¨ä¸Šé¢å®£å‘Šäº†
            if (dropZone) {
                dropZone.classList.add('drag-over');
            }
            // Clear any existing insertion lines
            this.hideDropIndicators();
            return;
        }
        
        const mouseY = e.clientY;
        let insertionIndex = -1;
        
        // Find where to show insertion line
        for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            const rect = card.getBoundingClientRect();
            const cardMiddle = rect.top + rect.height / 2;
            
            if (mouseY < cardMiddle) {
                insertionIndex = i;
                break;
            }
        }
        
        // Check if position has changed
        if (this.lastInsertionIndex === insertionIndex) {
            // Position hasn't changed, don't update
            return;
        }
        
        this.lastInsertionIndex = insertionIndex;
        
        // Clear existing indicators only when position changes
        this.hideDropIndicators();
        
        // Create and show insertion line
        const insertionLine = this.createInsertionLine();
        
        if (insertionIndex === -1) {
            // Insert at end
            const lastCard = cards[cards.length - 1];
            lastCard.insertAdjacentElement('afterend', insertionLine);
        } else if (insertionIndex === 0) {
            // Insert at beginning
            const firstCard = cards[0];
            firstCard.insertAdjacentElement('beforebegin', insertionLine);
        } else {
            // Insert between cards
            const targetCard = cards[insertionIndex];
            targetCard.insertAdjacentElement('beforebegin', insertionLine);
        }
        
        // Add active class immediately (no setTimeout needed)
        insertionLine.classList.add('active');
    }
    
    createInsertionLine() {
        const line = document.createElement('div');
        line.className = 'insertion-line';
        line.innerHTML = `
            <div class="insertion-line-inner">
                <div class="insertion-dot"></div>
                <div class="insertion-text">Drop here</div>
                <div class="insertion-dot"></div>
            </div>
        `;
        return line;
    }
    
    hideDropIndicators() {
        // ç§»é™¤èˆŠçš„ insertion-line
        document.querySelectorAll('.insertion-line').forEach(line => {
            line.remove();
        });
        // ç§»é™¤èˆŠçš„ drop-indicator
        document.querySelectorAll('.drop-indicator').forEach(line => {
            line.remove();
        });
        // ç§»é™¤æ–°çš„ placeholder (ä½†åœ¨æ‹–å‹•æœŸé–“ä¿ç•™ original-position-placeholder)
        const isDragging = document.body.classList.contains('dragging');
        if (isDragging) {
            // æ‹–å‹•æœŸé–“åªç§»é™¤éåŸå§‹ä½ç½®çš„ placeholder
            document.querySelectorAll('.tafl-card-placeholder:not(.original-position-placeholder)').forEach(p => {
                p.remove();
            });
        } else {
            // æ‹–å‹•çµæŸå¾Œç§»é™¤æ‰€æœ‰ placeholder
            document.querySelectorAll('.tafl-card-placeholder').forEach(p => {
                p.remove();
            });
        }
        // Reset the last insertion index
        this.lastInsertionIndex = undefined;
        this.lastIndicatorPosition = undefined;
    }
    
    refreshCardDragHandlers() {
        // All cards are already draggable through their draggable="true" attribute
        // Global event delegation handles all drag events - no need for individual setup
        // Just ensure all cards have the draggable attribute set
        const canvas = document.getElementById('flow-canvas');
        const allCards = canvas.querySelectorAll('.tafl-card'); // Include ALL cards, not just non-nested
        
        allCards.forEach(cardEl => {
            // Ensure draggable is set (should already be set by createCardElementSimple)
            if (!cardEl.draggable) {
                cardEl.draggable = true;
            }
        });
    }
    
    createInitialDropZone() {
        const canvas = document.getElementById('flow-canvas');
        const dropZone = document.getElementById('canvas-drop-zone');
        
        if (!dropZone) {
            console.error('Canvas drop zone not found');
            return;
        }
        
        // Set up main drop zone events
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            if (!dropZone.contains(e.relatedTarget)) {
                dropZone.classList.remove('drag-over');
            }
        });
        
        // Drop handler already exists in setupUnifiedDragDrop, no need for duplicate
    }
    
    /**
     * CARD MANAGEMENT WITH DRAG & DROP SUPPORT
     */
    addCard(verb) {
        // Delegate to cards module
        this.cardsModule.addCard(verb);
    }
    
    addCardAtPosition(verb, position) {
        // Delegate to cards module
        this.cardsModule.addCardAtPosition(verb, position);
    }
    
    moveCardToPosition(cardId, position) {
        // ç°¡åŒ–ç‰ˆï¼šç›´æ¥ä½¿ç”¨ Store çš„çµ±ä¸€é‚è¼¯
        console.log('ğŸš€ Moving card:', cardId, 'to position:', position);
        
        // æª¢æŸ¥æ˜¯å¦å¾åµŒå¥—ç§»å‹•
        const cardEl = document.querySelector(`[data-card-id="${cardId}"]`);
        const wasNested = cardEl && cardEl.closest('.nested-cards') !== null;
        console.log(`  Was nested: ${wasNested}, Target nested: ${!!position.nested}`);
        
        // åœ¨ç§»å‹•å‰æ¸…ç†æ‹–æ›³ç‹€æ…‹ï¼Œç¢ºä¿æ›´æ–°ä¸æœƒè¢«è·³é
        this.draggedElement = null;
        this.dragData = null;
        document.body.classList.remove('dragging');
        
        taflFlowStore.moveCard(cardId, position);
        // ä¸å†æ‰‹å‹•èª¿ç”¨ refreshCanvasï¼Œç”± card:moved äº‹ä»¶è™•ç†
        
        // è¦–è¦ºå›é¥‹
        setTimeout(() => {
            const movedCard = document.querySelector(`[data-card-id="${cardId}"]`);
            if (movedCard) {
                movedCard.classList.add('just-moved');
                setTimeout(() => movedCard.classList.remove('just-moved'), 500);
                this.selectCard(movedCard);
            }
        }, 100);
        
        this.markDirty();
        this.showNotification('Card moved successfully', 'is-success');
    }
    
    /**
     * ç°¡åŒ–ç‰ˆå¡ç‰‡å‰µå»ºï¼ˆä¸ç¶å®šå€‹åˆ¥äº‹ä»¶ï¼Œä½¿ç”¨äº‹ä»¶å§”æ´¾ï¼‰
     */
    createCardElementSimple(step) {
        // TAFL v1.1 Fix: Extract verb from step object
        const verb = step ? Object.keys(step).find(key => 
            this.verbDefinitions && this.verbDefinitions[key]
        ) : null;
        
        if (!verb) {
            console.warn('No valid verb found in step:', step);
            const emptyCard = document.createElement('div');
            emptyCard.className = 'tafl-card empty-card';
            emptyCard.innerHTML = '<div class="notification is-warning">Invalid step</div>';
            return emptyCard;
        }
        
        const verbDef = this.verbDefinitions[verb];
        
        // å‰µå»ºå¡ç‰‡å…ƒç´ ï¼ˆè¨­ç½® draggable å±¬æ€§ï¼‰
        const cardEl = document.createElement('div');
        cardEl.className = 'tafl-card';
        cardEl.dataset.cardId = step.id || this.generateId();
        cardEl.dataset.verb = verb;
        cardEl.draggable = true; // ç¢ºä¿æ‰€æœ‰å¡ç‰‡éƒ½å¯æ‹–å‹•
        
        cardEl.innerHTML = `
            <div class="tafl-card-header">
                <div class="card-drag-handle" title="Drag to reorder">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <span class="tag verb-badge is-${verb}">${verbDef.name}</span>
                <h3 class="card-title">${this.getCardTitle(step)}</h3>
                <div class="card-controls">
                    <button class="button is-small card-duplicate-btn" title="Duplicate">
                        <span class="icon is-small">
                            <i class="fas fa-copy"></i>
                        </span>
                    </button>
                    <button class="button is-small card-delete-btn" title="Delete">
                        <span class="icon is-small">
                            <i class="fas fa-trash"></i>
                        </span>
                    </button>
                </div>
            </div>
            <div class="tafl-card-body">
                ${this.renderCardParams(step)}
            </div>
            ${this.renderNestedCardsSimple(step)}
        `;
        
        // è¨­ç½® comment tooltipï¼ˆå¦‚æœæœ‰ï¼‰
        if (step.comment) {
            cardEl.title = step.comment;
        }
        
        return cardEl;
    }
    
    /**
     * ç°¡åŒ–ç‰ˆå·¢ç‹€å¡ç‰‡æ¸²æŸ“ï¼ˆéè¿´æ¸²æŸ“æ‰€æœ‰å±¤ç´šï¼‰
     */
    renderNestedCardsSimple(cardData) {
        const verb = this.getCardVerb(cardData);
        const params = cardData[verb];
        let html = '';
        
        if (typeof params === 'object') {
            if (verb === 'if') {
                if (params.then && Array.isArray(params.then)) {
                    html += this.renderNestedBranchSimple('then', params.then);
                }
                if (params.else && Array.isArray(params.else)) {
                    html += this.renderNestedBranchSimple('else', params.else);
                }
            } else if (verb === 'for' && params.do && Array.isArray(params.do)) {
                html += this.renderNestedBranchSimple('do', params.do);
            } else if (verb === 'switch') {
                if (params.cases && Array.isArray(params.cases)) {
                    params.cases.forEach((caseItem, index) => {
                        html += this.renderNestedBranchSimple(`case-${index}`, caseItem.do || []);
                    });
                }
                if (params.default && Array.isArray(params.default)) {
                    html += this.renderNestedBranchSimple('default', params.default);
                }
            }
        }
        
        return html;
    }
    
    /**
     * ç°¡åŒ–ç‰ˆå·¢ç‹€åˆ†æ”¯æ¸²æŸ“
     */
    renderNestedBranchSimple(branchType, cards) {
        if (!Array.isArray(cards)) return '';
        
        const branchClass = branchType.replace(/[^a-zA-Z0-9]/g, '-');
        
        let html = `
            <div class="nested-cards ${branchClass}-cards" data-branch="${branchType}">
                <div class="branch-label">${branchType}</div>
        `;
        
        if (cards.length === 0) {
            // ç©ºçš„å·¢ç‹€æ”¾ç½®å€
            html += `
                <div class="nested-drop-zone empty-zone" data-branch="${branchType}">
                    <div class="nested-drop-content">
                        <i class="mdi mdi-plus"></i>
                        <span>Add cards here</span>
                    </div>
                </div>
            `;
        } else {
            // éè¿´æ¸²æŸ“å·¢ç‹€å¡ç‰‡
            cards.forEach(nestedCard => {
                const nestedElement = this.createCardElementSimple(nestedCard);
                html += nestedElement.outerHTML;
            });
        }
        
        html += `</div>`;
        return html;
    }
    
    // Removed unused createCardElement function - using createCardElementSimple instead
    
    setupCommentTooltip(cardEl, cardData) {
        // Check if card has a comment
        if (!cardData.comment) return;
        
        // Create tooltip element
        let tooltip = null;
        
        const showTooltip = (e) => {
            // Don't show tooltip when interacting with inputs
            if (e.target.closest('input') || e.target.closest('textarea') || e.target.closest('button')) {
                return;
            }
            
            // Create tooltip if not exists
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.className = 'tafl-comment-tooltip';
                tooltip.innerHTML = `
                    <div class="tooltip-arrow"></div>
                    <div class="tooltip-content">
                        <strong>Comment:</strong><br>
                        ${this.escapeHtml(cardData.comment)}
                    </div>
                `;
                tooltip.style.cssText = `
                    position: absolute;
                    background: #363636;
                    color: white;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 14px;
                    max-width: 300px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    z-index: 10000;
                    pointer-events: none;
                    opacity: 0;
                    transition: opacity 0.2s;
                `;
                document.body.appendChild(tooltip);
            }
            
            // Position tooltip above the card
            const rect = cardEl.getBoundingClientRect();
            tooltip.style.left = rect.left + (rect.width / 2) + 'px';
            tooltip.style.top = (rect.top - 10) + 'px';
            tooltip.style.transform = 'translate(-50%, -100%)';
            
            // Show tooltip with animation
            requestAnimationFrame(() => {
                tooltip.style.opacity = '1';
            });
        };
        
        const hideTooltip = () => {
            if (tooltip) {
                tooltip.style.opacity = '0';
                setTimeout(() => {
                    if (tooltip && tooltip.parentNode) {
                        tooltip.parentNode.removeChild(tooltip);
                        tooltip = null;
                    }
                }, 200);
            }
        };
        
        // Add hover event listeners
        cardEl.addEventListener('mouseenter', showTooltip);
        cardEl.addEventListener('mouseleave', hideTooltip);
        
        // Clean up on card removal
        cardEl.addEventListener('remove', hideTooltip);
    }
    
    /**
     * NESTED STRUCTURES SUPPORT
     */
    renderNestedCards(cardData) {
        // TAFL v1.1: Extract verb from object keys (verb is the key, not a property)
        const verb = this.getCardVerb(cardData);
        const params = cardData[verb];
        let html = '';
        
        if (typeof params === 'object') {
            if (verb === 'if') {
                if (params.then && Array.isArray(params.then)) {
                    html += this.renderNestedBranch('then', params.then);
                }
                if (params.else && Array.isArray(params.else)) {
                    html += this.renderNestedBranch('else', params.else);
                }
            } else if (verb === 'for' && params.do && Array.isArray(params.do)) {
                html += this.renderNestedBranch('do', params.do);
            } else if (verb === 'switch') {
                if (params.cases && Array.isArray(params.cases)) {
                    params.cases.forEach((caseItem, index) => {
                        html += this.renderNestedBranch(`case-${index}`, caseItem.do || []);
                    });
                }
                if (params.default && Array.isArray(params.default)) {
                    html += this.renderNestedBranch('default', params.default);
                }
            }
        }
        
        return html;
    }
    
    renderNestedBranch(branchType, cards) {
        if (!Array.isArray(cards)) return '';
        
        const branchClass = branchType.replace(/[^a-zA-Z0-9]/g, '-');
        
        let html = `
            <div class="nested-cards ${branchClass}-cards" data-branch="${branchType}">
                <div class="branch-label">${branchType}</div>
        `;
        
        // Only show drop zone if empty or during drag
        if (cards.length === 0) {
            html += `
                <div class="nested-drop-zone empty-zone" data-branch="${branchType}">
                    <div class="nested-drop-content">
                        <i class="mdi mdi-plus"></i>
                        <span>Add cards here</span>
                    </div>
                </div>
            `;
        } else {
            // Add horizontal drop indicator (initially hidden)
            html += `<div class="drop-indicator horizontal" data-branch="${branchType}" data-position="0"></div>`;
            
            cards.forEach((nestedCard, index) => {
                html += this.renderNestedCard(nestedCard);
                // Add drop indicator after each card
                html += `<div class="drop-indicator horizontal" data-branch="${branchType}" data-position="${index + 1}"></div>`;
            });
        }
        
        html += `</div>`;
        
        return html;
    }
    
    renderNestedCard(cardData) {
        // For nested cards, render a simplified version
        const verb = Object.keys(cardData).find(key => key !== 'id' && this.verbDefinitions[key]);
        if (!verb) return '';
        
        const verbDef = this.verbDefinitions[verb];
        
        // Ensure card has an ID
        if (!cardData.id) {
            cardData.id = this.generateId();
        }
        
        // Create the full card data structure for rendering
        const fullCardData = {
            [verb]: cardData[verb],
            id: cardData.id
        };
        
        return `
            <div class="tafl-card nested" data-card-id="${cardData.id}" data-verb="${verb}">
                <div class="tafl-card-header">
                    <div class="card-drag-handle" title="Drag to reorder">
                        <i class="fas fa-grip-vertical"></i>
                    </div>
                    <span class="tag verb-badge is-${verb}">${verbDef.name}</span>
                    <h3 class="card-title">${this.getCardTitle({verb, [verb]: cardData[verb]})}</h3>
                    <div class="card-controls">
                        <button class="button is-small card-duplicate-btn" title="Duplicate">
                            <span class="icon is-small">
                                <i class="fas fa-copy"></i>
                            </span>
                        </button>
                        <button class="button is-small card-delete-btn" title="Delete">
                            <span class="icon is-small">
                                <i class="fas fa-trash"></i>
                            </span>
                        </button>
                    </div>
                </div>
                <div class="tafl-card-body">
                    ${this.renderCardParams(fullCardData)}
                </div>
                ${this.renderNestedCards(fullCardData)}
            </div>
        `;
    }
    
    getNestedDropTarget(element) {
        return element.closest('.nested-drop-zone');
    }
    
    getBranchType(nestedArea) {
        return nestedArea?.dataset?.branch || null;
    }
    
    addToNestedStructure(parentCardId, branchType, cardData) {
        // Ensure the card has an ID
        if (!cardData.id) {
            cardData.id = this.generateId();
        }
        
        // Get the current flow
        const flow = taflFlowStore.getFlow();
        
        // Create position object
        const position = {
            nested: {
                parentCardId: parentCardId,
                branchType: branchType
            }
        };
        
        // Use the store's method to insert into nested structure
        const updatedFlow = taflFlowStore.insertCardInNested(flow.flow, cardData, position);
        
        if (!updatedFlow) {
            console.error('Failed to add card to nested structure');
            return;
        }
        
        // Update the flow in the store
        taflFlowStore.updateFlow({ ...flow, flow: updatedFlow });
        
        console.log('âœ… Added card to nested structure:', parentCardId, branchType, cardData);
    }
    
    addToNestedStructureAtPosition(parentCardId, branchType, cardData, position) {
        // Ensure the card has an ID
        if (!cardData.id) {
            cardData.id = this.generateId();
        }
        
        // Get the current flow
        const flow = taflFlowStore.getFlow();
        
        // Create position object
        const positionObj = {
            nested: {
                parentCardId: parentCardId,
                branchType: branchType
            },
            index: position
        };
        
        // Use the store's method to insert into nested structure
        const updatedFlow = taflFlowStore.insertCardInNested(flow.flow, cardData, positionObj);
        
        if (!updatedFlow) {
            console.error('Failed to add card to nested structure at position');
            return;
        }
        
        // Update the flow in the store
        taflFlowStore.updateFlow({ ...flow, flow: updatedFlow });
        
        console.log('âœ… Added card to nested structure at position:', parentCardId, branchType, position, cardData);
    }
    
    /**
     * REST OF THE CLASS METHODS (keeping existing functionality)
     */
    
    // Delegate to variables module
    initializeVariables() {
        return this.variablesModule.initializeVariables();
    }
    
    // ============================================
    // Legacy Panel Functions (Deprecated)
    // All panel innerHTML updates now handled by SimpleTAFLPanels
    // These modal functions kept for backward compatibility
    // ============================================
    
    updateSaveButton(isDirty) {
        // Delegate to notifications module
        this.notificationsModule.updateSaveButton(isDirty);
    }
    
    // Removed: refreshVariablesUI - handled by SimpleTAFLPanels
    
    // setupModalControls() moved to tafl-editor-modals.js
    
    
    initializeDisplayModes() {
        const modeButtons = document.querySelectorAll('.mode-button');
        const contentWrapper = document.querySelector('.tafl-content-wrapper');
        const toggleBtn = document.getElementById('toggle-properties-btn');
        const editorContainer = document.querySelector('.columns.is-gapless');
        
        modeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Toggle properties panel - just toggle a class on the parent container
                if (button.classList.contains('toggle-properties')) {
                    editorContainer.classList.toggle('properties-collapsed');
                    
                    // Refresh CodeMirror if needed
                    const currentMode = document.querySelector('.mode-button.is-active[data-mode]');
                    if (currentMode && (currentMode.dataset.mode === 'yaml' || currentMode.dataset.mode === 'both') && this.yamlModule && this.yamlModule.yamlEditor) {
                        setTimeout(() => this.yamlModule.yamlEditor.refresh(), 100);
                    }
                    return;
                }
                
                // Normal mode buttons
                if (button.dataset.mode) {
                    modeButtons.forEach(btn => {
                        if (btn.dataset.mode) btn.classList.remove('is-active');
                    });
                    button.classList.add('is-active');
                    
                    const mode = button.dataset.mode;
                    contentWrapper.className = `tafl-content-wrapper mode-${mode}`;
                    
                    if ((mode === 'yaml' || mode === 'both') && this.yamlModule) {
                        setTimeout(() => {
                            // Always refresh YAML content when switching to YAML view
                            this.yamlModule.refreshYAML();
                            // Refresh CodeMirror editor if it exists
                            if (this.yamlModule.yamlEditor) {
                                this.yamlModule.yamlEditor.refresh();
                            }
                            console.log('ğŸ“ YAML view refreshed on mode switch');
                        }, 100);
                    }
                }
            });
        });
    }
    
    getDefaultParams(verb) {
        // Update utils module with current verb definitions
        this.utilsModule.verbDefinitions = this.verbDefinitions;
        // Delegate to utils module
        return this.utilsModule.getDefaultParams(verb);
    }
    
    
    getCardTitle(cardData) {
        // Delegate to utils module (since cards module is not initialized yet)
        return this.utilsModule.getCardTitle(cardData);
    }
    
    renderCardParams(cardData) {
        // Delegate to cards module
        return this.cardsModule.renderCardParams(cardData);
    }
    
    formatParamValue(value) {
        // Delegate to utils module
        return this.utilsModule.formatParamValue(value);
    }
    
    selectCard(cardElement) {
        // Delegate to cards module
        this.cardsModule.selectCard(cardElement);
        // Removed: this.selectedCard - now managed by Store
    }
    
    deselectCard() {
        // Delegate to Store
        taflFlowStore.deselectCard();
        // UI update handled by Store events
    }
    
    // Properties panel methods removed - handled by tafl-editor-properties.js and tafl-panels-properties.js modules
    // The following methods have been migrated to dedicated modules:
    // - updatePropertiesPanel() â†’ tafl-panels-properties.js
    // - renderPropertyEditor() â†’ tafl-editor-properties.js
    // - renderSwitchCasesEditor() â†’ tafl-editor-properties.js
    // - renderPropertyField() â†’ tafl-editor-properties.js
    // - setupPropertyEditing() â†’ tafl-panels-properties.js
    // - updatePropertyValue() â†’ tafl-editor-properties.js
    // - applyPropertyChanges() â†’ tafl-editor-properties.js
            propertiesPanel.innerHTML = `
                <div class="no-selection">
                    <div class="has-text-centered">
                        <span class="icon is-large has-text-grey-light">
                            <i class="fas fa-mouse-pointer fa-3x"></i>
                        </span>
                        <p class="has-text-grey">Select a card to edit properties</p>
                    </div>
                </div>
            `;
            return;
        }
        
        const cardId = this.selectedCard.dataset.cardId;
        const cardData = this.findCardById(cardId);
        
        if (!cardData) {
            console.error('Card data not found for ID:', cardId);
            propertiesPanel.innerHTML = `
                <div class="no-selection">
                    <div class="has-text-centered">
                        <span class="icon is-large has-text-danger">
                            <i class="fas fa-exclamation-triangle fa-3x"></i>
                        </span>
                        <p class="has-text-danger">Card data not found</p>
                    </div>
                </div>
            `;
            return;
        }
        
        const verb = this.getCardVerb(cardData);
        const verbDef = this.verbDefinitions[verb];
        
        if (!verbDef) {
            console.error('Verb definition not found for:', verb);
            return;
        }
        
        propertiesPanel.innerHTML = `
            <div class="property-editor">
                <h4 class="title is-5">Properties</h4>
                
                <div class="field">
                    <label class="label">Type: ${verbDef.name}</label>
                </div>
                
                <div class="property-fields">
                    ${this.renderPropertyEditor(cardData)}
                </div>
                
                <hr>
                
                <div class="field">
                    <label class="label">Card ID</label>
                    <div class="control">
                        <input class="input is-small" type="text" value="${cardData.id || ''}" readonly>
                    </div>
                </div>
                
                <div class="field">
                    <label class="label">Comment</label>
                    <div class="control">
                        <textarea class="textarea is-small property-input" 
                                  data-card-id="${cardId}" 
                                  data-param="comment" 
                                  rows="2"
                                  placeholder="Add a comment...">${cardData.comment || ''}</textarea>
                    </div>
                    <p class="help">Optional comment for documentation</p>
                </div>
                
                <div class="field is-grouped">
                    <p class="control">
                        <button class="button is-small is-primary" id="apply-properties">
                            <span class="icon">
                                <i class="fas fa-check"></i>
                            </span>
                            <span>Apply All</span>
                        </button>
                    </p>
                    <p class="control">
                        <button class="button is-small is-danger" id="delete-card">
                            <span class="icon">
                                <i class="fas fa-trash"></i>
                            </span>
                            <span>Delete Card</span>
                        </button>
                    </p>
                </div>
            </div>
        `;
        
        // Add event listeners for property editing
        this.setupPropertyEditing(cardData);
    }
    
    renderPropertyEditor(cardData) {
        const verb = this.getCardVerb(cardData);
        const params = cardData[verb];
        const cardId = cardData.id;
        let html = '';
        
        // Special handling for switch card
        if (verb === 'switch') {
            return this.renderSwitchCasesEditor(cardData);
        }
        
        if (!params) {
            return '<p class="has-text-grey">No parameters</p>';
        }
        
        if (typeof params === 'string') {
            // Simple string parameter (set, stop)
            html += `
                <div class="field">
                    <label class="label">Value</label>
                    <div class="control">
                        <textarea class="textarea is-small property-input" 
                                  data-card-id="${cardId}" 
                                  data-param="_root" 
                                  rows="2">${this.escapeHtml(params)}</textarea>
                    </div>
                </div>
            `;
        } else if (typeof params === 'object') {
            // Render common parameters first
            const commonParams = ['target', 'condition', 'each', 'in', 'value', 'filter', 'limit', 'id'];
            const renderedParams = new Set();
            
            // Render common params in order
            for (const key of commonParams) {
                if (key in params) {
                    html += this.renderPropertyField(cardId, key, params[key]);
                    renderedParams.add(key);
                }
            }
            
            // Render remaining params
            for (const [key, value] of Object.entries(params)) {
                if (!renderedParams.has(key) && 
                    key !== 'then' && key !== 'else' && 
                    key !== 'do' && key !== 'cases' && key !== 'default') {
                    html += this.renderPropertyField(cardId, key, value);
                }
            }
        }
        
        return html || '<p class="has-text-grey">No editable parameters</p>';
    }
    
    renderSwitchCasesEditor(cardData) {
        const switchParams = cardData.switch;
        const cardId = cardData.id;
        const cases = switchParams.cases || [];
        const hasDefaultCase = cases.some(c => c.when === "default");
        
        let html = `
            <!-- Expression field -->
            <div class="field">
                <label class="label">Expression</label>
                <div class="control">
                    <input class="input is-small property-input" 
                           type="text" 
                           data-card-id="${cardId}" 
                           data-param="expression"
                           value="${this.escapeHtml(switchParams.expression || '')}"
                           placeholder="e.g., \${task_priority}">
                </div>
                <p class="help">The variable or expression to evaluate</p>
            </div>
            
            <!-- Cases management -->
            <div class="field">
                <label class="label">Cases</label>
                
                <!-- Add Case button at the top -->
                <div class="mb-2">
                    <button class="button is-small is-info" id="add-case-btn" data-card-id="${cardId}">
                        <span class="icon"><i class="fas fa-plus"></i></span>
                        <span>Add Case</span>
                    </button>
                    ${!hasDefaultCase ? `
                        <button class="button is-small is-warning ml-2" id="add-default-btn" data-card-id="${cardId}">
                            <span class="icon"><i class="fas fa-plus"></i></span>
                            <span>Add Default</span>
                        </button>
                    ` : ''}
                </div>
                
                <!-- Cases list -->
                <div class="cases-list" id="switch-cases-list">
        `;
        
        if (cases.length === 0) {
            html += '<p class="has-text-grey is-italic">No cases defined. Click "Add Case" to create one.</p>';
        } else {
            // Render each case's when condition editor
            cases.forEach((caseItem, index) => {
                const isDefault = caseItem.when === "default";
                const isFirst = index === 0;
                const isLast = index === cases.length - 1;
                const isBeforeDefault = !isLast && cases[index + 1]?.when === "default";
                
                html += `
                    <div class="case-item box mb-2" data-case-index="${index}" style="padding: 0.5rem;">
                        <div class="field has-addons mb-0">
                            <!-- Move controls -->
                            <p class="control">
                                <button class="button is-small ${isFirst || isDefault ? 'is-static' : ''}" 
                                        data-card-id="${cardId}"
                                        data-case-index="${index}"
                                        ${isFirst || isDefault ? 'disabled' : ''}
                                        onclick="window.taflEditor.moveSwitchCase('${cardId}', ${index}, 'up')"
                                        title="Move up">
                                    <span class="icon is-small"><i class="fas fa-arrow-up"></i></span>
                                </button>
                            </p>
                            <p class="control">
                                <button class="button is-small ${isLast || isBeforeDefault ? 'is-static' : ''}" 
                                        data-card-id="${cardId}"
                                        data-case-index="${index}"
                                        ${isLast || isBeforeDefault ? 'disabled' : ''}
                                        onclick="window.taflEditor.moveSwitchCase('${cardId}', ${index}, 'down')"
                                        title="Move down">
                                    <span class="icon is-small"><i class="fas fa-arrow-down"></i></span>
                                </button>
                            </p>
                            
                            <!-- Case label -->
                            <p class="control">
                                <span class="button is-static is-small">
                                    ${isDefault ? 
                                        '<span class="has-text-warning-dark"><strong>Default</strong></span>' : 
                                        'When'}
                                </span>
                            </p>
                            
                            <!-- Case input -->
                            <p class="control is-expanded">
                                ${isDefault ? 
                                    '<input class="input is-small" value="(always matches)" readonly disabled style="background: #fffbeb;">' :
                                    `<input class="input is-small case-when-input" 
                                           data-card-id="${cardId}"
                                           data-case-index="${index}"
                                           value="${this.escapeHtml(caseItem.when || '')}"
                                           placeholder='e.g., "> 8" or "5..8" or "urgent"'>`
                                }
                            </p>
                            
                            <!-- Remove button -->
                            <p class="control">
                                <button class="button is-small is-danger is-light remove-case-btn" 
                                        data-card-id="${cardId}"
                                        data-case-index="${index}"
                                        title="Remove this case">
                                    <span class="icon"><i class="fas fa-trash"></i></span>
                                </button>
                            </p>
                        </div>
                    </div>
                `;
            });
        }
        
        html += `
                </div>
            </div>
        `;
        
        return html;
    }
    
    renderPropertyField(cardId, key, value) {
        let inputHTML = '';
        
        if (typeof value === 'string') {
            if (value.length > 50 || value.includes('\n')) {
                inputHTML = `
                    <textarea class="textarea is-small property-input" 
                              data-card-id="${cardId}" 
                              data-param="${key}" 
                              rows="3">${this.escapeHtml(value)}</textarea>
                `;
            } else {
                inputHTML = `
                    <input class="input is-small property-input" 
                           type="text" 
                           data-card-id="${cardId}" 
                           data-param="${key}" 
                           value="${this.escapeHtml(value)}">
                `;
            }
        } else if (typeof value === 'number') {
            inputHTML = `
                <input class="input is-small property-input" 
                       type="number" 
                       data-card-id="${cardId}" 
                       data-param="${key}" 
                       value="${value}">
            `;
        } else if (typeof value === 'boolean') {
            inputHTML = `
                <label class="checkbox">
                    <input type="checkbox" 
                           class="property-input" 
                           data-card-id="${cardId}" 
                           data-param="${key}" 
                           ${value ? 'checked' : ''}>
                    <span class="ml-2">${value ? 'Yes' : 'No'}</span>
                </label>
            `;
        } else if (value === null || value === undefined) {
            inputHTML = `
                <input class="input is-small property-input" 
                       type="text" 
                       data-card-id="${cardId}" 
                       data-param="${key}" 
                       value="" 
                       placeholder="Not set">
            `;
        } else if (Array.isArray(value) || typeof value === 'object') {
            // For arrays and objects, show as JSON
            inputHTML = `
                <textarea class="textarea is-small property-input" 
                          data-card-id="${cardId}" 
                          data-param="${key}" 
                          rows="4">${JSON.stringify(value, null, 2)}</textarea>
            `;
        }
        
        return `
            <div class="field">
                <label class="label">${this.formatParamName(key)}</label>
                <div class="control">
                    ${inputHTML}
                </div>
                ${this.getParamHelp(key)}
            </div>
        `;
    }
    
    formatParamName(name) {
        // Delegate to utils module
        return this.utilsModule.formatParamName(name);
    }
    
    getParamHelp(param) {
        // Delegate to utils module
        return this.utilsModule.getParamHelp(param);
    }
    
    escapeHtml(text) {
        // Delegate to utils module
        return this.utilsModule.escapeHtml(text);
    }
    
    setupPropertyEditing(cardData) {
        const verb = this.getCardVerb(cardData);
        
        // Apply properties button
        const applyBtn = document.getElementById('apply-properties');
        applyBtn?.addEventListener('click', () => {
            this.applyAllPropertyChanges();
        });
        
        // Delete card button
        const deleteBtn = document.getElementById('delete-card');
        deleteBtn?.addEventListener('click', () => {
            this.deleteCard(cardData.id);
        });
        
        // Special handling for switch card
        if (verb === 'switch') {
            // Add case button
            document.getElementById('add-case-btn')?.addEventListener('click', () => {
                this.addSwitchCase(cardData.id);
            });
            
            // Add default button
            document.getElementById('add-default-btn')?.addEventListener('click', () => {
                this.toggleDefault(cardData.id, true);
            });
            
            // Remove default button
            document.getElementById('remove-default-btn')?.addEventListener('click', () => {
                this.toggleDefault(cardData.id, false);
            });
            
            // Remove case buttons
            document.querySelectorAll('.remove-case-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const caseIndex = parseInt(e.currentTarget.dataset.caseIndex);
                    this.removeSwitchCase(cardData.id, caseIndex);
                });
            });
            
            // When condition editing
            document.querySelectorAll('.case-when-input').forEach(input => {
                input.addEventListener('input', (e) => {
                    const caseIndex = parseInt(e.target.dataset.caseIndex);
                    this.updateCaseWhen(cardData.id, caseIndex, e.target.value);
                });
            });
            
            // Move case buttons
            document.querySelectorAll('.move-case-up:not([disabled])').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const caseIndex = parseInt(e.currentTarget.dataset.caseIndex);
                    this.moveSwitchCase(cardData.id, caseIndex, 'up');
                });
            });
            
            document.querySelectorAll('.move-case-down:not([disabled])').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const caseIndex = parseInt(e.currentTarget.dataset.caseIndex);
                    this.moveSwitchCase(cardData.id, caseIndex, 'down');
                });
            });
        }
        
        // Real-time property updates
        document.querySelectorAll('.property-input').forEach(input => {
            // Remove any existing listeners
            const newInput = input.cloneNode(true);
            input.parentNode.replaceChild(newInput, input);
            
            // Add debounced change listener
            let timeout;
            const updateValue = () => {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    this.updatePropertyValue(newInput);
                }, 300);
            };
            
            if (newInput.type === 'checkbox') {
                newInput.addEventListener('change', updateValue);
            } else {
                newInput.addEventListener('input', updateValue);
            }
        });
    }
    
    updatePropertyValue(input) {
        const cardId = input.dataset.cardId;
        const param = input.dataset.param;
        const cardData = this.findCardById(cardId);
        
        if (!cardData) {
            console.error('Card not found:', cardId);
            return;
        }
        
        let value = input.type === 'checkbox' ? input.checked : input.value;
        
        // Try to parse as JSON if it looks like JSON
        if (typeof value === 'string' && (value.startsWith('[') || value.startsWith('{'))) {
            try {
                value = JSON.parse(value);
            } catch (e) {
                // Keep as string if not valid JSON
            }
        } else if (typeof value === 'string' && value.match(/^\d+$/)) {
            // Keep numeric strings as strings unless they're IDs
            if (param !== 'id' && param !== 'target') {
                value = parseInt(value);
            }
        } else if (typeof value === 'string' && value.match(/^\d+\.\d+$/)) {
            // Convert decimal strings to floats
            value = parseFloat(value);
        }
        
        const verb = this.getCardVerb(cardData);
        
        if (param === '_root') {
            // For simple string parameters
            cardData[verb] = value;
        } else if (param === 'comment') {
            // Update comment field
            if (value) {
                cardData.comment = value;
            } else {
                delete cardData.comment;
            }
        } else {
            // For object parameters
            if (typeof cardData[verb] === 'object') {
                if (value === '' || value === null) {
                    delete cardData[verb][param];
                } else {
                    cardData[verb][param] = value;
                }
            }
        }
        
        // Update card display immediately
        this.refreshCard(cardId);
        this.markDirty();
        
        // Show visual feedback
        input.classList.add('is-success');
        setTimeout(() => {
            input.classList.remove('is-success');
        }, 500);
    }
    
    applyAllPropertyChanges() {
        // Apply all pending changes
        document.querySelectorAll('.property-input').forEach(input => {
            this.updatePropertyValue(input);
        });
        
        this.showNotification('Properties updated', 'is-success');
        this.updateUI();
    }
    
    applyPropertyChanges(cardData) {
        // Legacy method for compatibility
        this.applyAllPropertyChanges();
    }
    
    refreshCard(cardId) {
        const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
        const cardData = this.findCardById(cardId);
        
        if (!cardElement || !cardData) return;
        
        // Update title
        const titleElement = cardElement.querySelector('.card-title');
        if (titleElement) {
            titleElement.textContent = this.getCardTitle(cardData);
        }
        
        // Update parameters display
        const bodyElement = cardElement.querySelector('.tafl-card-body');
        if (bodyElement) {
            bodyElement.innerHTML = this.renderCardParams(cardData);
        }
    }
    
    findCardById(cardId) {
        return taflFlowStore.findCardById(cardId);
    }
    
    findCardInArray(cards, cardId) {
        for (const card of cards) {
            if (card.id === cardId) {
                return card;
            }
            
            // Search in nested structures
            const verb = this.getCardVerb(card);
            const params = card[verb];
            if (typeof params === 'object') {
                const nested = ['then', 'else', 'do', 'cases', 'default'];
                for (const key of nested) {
                    if (params[key] && Array.isArray(params[key])) {
                        const found = this.findCardInArray(params[key], cardId);
                        if (found) return found;
                    }
                }
            }
        }
        return null;
    }
    
    duplicateCard(cardId) {
        // Delegate to cards module
        this.cardsModule.duplicateCard(cardId);
    }
    
    getCardById(cardId) {
        // Helper method to find a card by ID in the flow
        for (const card of taflFlowStore.getFlow().flow) {
            if (card.id === cardId) {
                return card;
            }
            // Check nested structures (if, for, switch branches)
            if (card.then_branch) {
                const found = this.findCardInBranch(card.then_branch, cardId);
                if (found) return found;
            }
            if (card.else_branch) {
                const found = this.findCardInBranch(card.else_branch, cardId);
                if (found) return found;
            }
            if (card.body) {
                const found = this.findCardInBranch(card.body, cardId);
                if (found) return found;
            }
            if (card.cases) {
                for (const caseItem of card.cases) {
                    const found = this.findCardInBranch(caseItem.body, cardId);
                    if (found) return found;
                }
            }
        }
        return null;
    }
    
    findCardInBranch(branch, cardId) {
        if (!branch) return null;
        for (const card of branch) {
            if (card.id === cardId) {
                return card;
            }
        }
        return null;
    }
    
    async deleteCard(cardId) {
        console.log('ğŸ—‘ï¸ TAFLEditor.deleteCard() called for:', cardId);
        
        if (!await taflModals.confirmDelete('card')) {
            return;
        }
        
        // Store the flow state before deletion for debugging
        const flowBefore = taflFlowStore.getFlow();
        console.log('ğŸ—‘ï¸ Flow before delete:', flowBefore.flow.length, 'cards');
        
        // Delegate to cards module which will update store and emit event
        this.cardsModule.deleteCard(cardId);
        
        // Force immediate refresh after delete
        // The event handler will also trigger, but this ensures immediate update
        setTimeout(() => {
            const flowAfter = taflFlowStore.getFlow();
            console.log('ğŸ—‘ï¸ Flow after delete:', flowAfter.flow.length, 'cards');
            
            // Force full canvas refresh
            this.refreshCanvasCore();
            
            // Show drop zone if no cards left
            if (flowAfter.flow.length === 0) {
                const dropZone = document.getElementById('canvas-drop-zone');
                if (dropZone) {
                    dropZone.style.display = 'flex';
                }
            }
            
            // Update YAML view
            this.yamlModule.refreshYAML();
            
            // Update UI elements
            this.updateUI();
        }, 100);
        
        // Deselect if this was the selected card
        if (this.selectedCard && this.selectedCard.dataset.cardId === cardId) {
            this.deselectCard();
        }
        
        this.markDirty();
        this.showNotification('Card deleted', 'is-success');
    }
    
    removeCardFromFlow(cardId) {
        taflFlowStore.deleteCard(cardId);
    }
    
    removeFromNestedStructures(cards, cardId) {
        for (const card of cards) {
            const verb = this.getCardVerb(card);
            const params = card[verb];
            
            if (typeof params === 'object') {
                const nestedKeys = ['then', 'else', 'do', 'cases', 'default'];
                for (const key of nestedKeys) {
                    if (params[key] && Array.isArray(params[key])) {
                        params[key] = params[key].filter(nestedCard => nestedCard.id !== cardId);
                        this.removeFromNestedStructures(params[key], cardId);
                    }
                }
            }
        }
    }
    
    removeNestedCard(cardId) {
        // Remove from main flow and nested structures
        this.removeCardFromFlow(cardId);
        return true;
    }
    
    // ============================================
    // Switch Cases Management Functions
    // ============================================
    
    addSwitchCase(cardId) {
        const cardData = this.findCardById(cardId);
        if (!cardData || !cardData.switch) return;
        
        if (!cardData.switch.cases) {
            cardData.switch.cases = [];
        }
        
        // Find if there's a default case at the end
        const defaultIndex = cardData.switch.cases.findIndex(c => c.when === "default");
        
        // Create new case
        const newCase = {
            when: "",
            do: []
        };
        
        // If there's a default case, insert before it; otherwise append
        if (defaultIndex !== -1) {
            cardData.switch.cases.splice(defaultIndex, 0, newCase);
        } else {
            cardData.switch.cases.push(newCase);
        }
        
        // Refresh the properties panel to show the new case
        this.updatePropertiesPanel();
        
        // Refresh the card to show the new case drop zone
        this.refreshCard(cardId);
        
        console.log('Added new case to switch:', cardData);
    }
    
    removeSwitchCase(cardId, caseIndex) {
        const cardData = this.findCardById(cardId);
        if (!cardData || !cardData.switch || !cardData.switch.cases) return;
        
        // Remove the case at the specified index
        cardData.switch.cases.splice(caseIndex, 1);
        
        // Refresh the properties panel
        this.updatePropertiesPanel();
        
        // Refresh the card to update the display
        this.refreshCard(cardId);
        
        console.log(`Removed case ${caseIndex} from switch:`, cardData);
    }
    
    updateCaseWhen(cardId, caseIndex, newWhen) {
        const cardData = this.findCardById(cardId);
        if (!cardData || !cardData.switch || !cardData.switch.cases) return;
        
        if (cardData.switch.cases[caseIndex]) {
            cardData.switch.cases[caseIndex].when = newWhen;
            
            // Only update the card display, not the properties panel
            this.refreshCard(cardId);
            
            console.log(`Updated case ${caseIndex} when to "${newWhen}":`, cardData);
        }
    }
    
    toggleDefault(cardId, add = true) {
        const cardData = this.findCardById(cardId);
        if (!cardData || !cardData.switch) return;
        
        if (add) {
            // Add default as a special case at the end
            if (!cardData.switch.cases) {
                cardData.switch.cases = [];
            }
            // Check if default already exists
            const hasDefault = cardData.switch.cases.some(c => c.when === "default");
            if (!hasDefault) {
                cardData.switch.cases.push({
                    when: "default",
                    do: []
                });
            }
        } else {
            // Remove default case
            if (cardData.switch.cases) {
                cardData.switch.cases = cardData.switch.cases.filter(c => c.when !== "default");
            }
        }
        
        // Refresh the properties panel
        this.updatePropertiesPanel();
        
        // Refresh the card to show/hide the default drop zone
        this.refreshCard(cardId);
        
        console.log(`${add ? 'Added' : 'Removed'} default case:`, cardData);
    }
    
    moveSwitchCase(cardId, caseIndex, direction) {
        const cardData = this.findCardById(cardId);
        if (!cardData || !cardData.switch || !cardData.switch.cases) return;
        
        const cases = cardData.switch.cases;
        const targetIndex = direction === 'up' ? caseIndex - 1 : caseIndex + 1;
        
        // Boundary check
        if (targetIndex < 0 || targetIndex >= cases.length) return;
        
        // Check if trying to move default case or move something after default
        const isMovingDefault = cases[caseIndex].when === "default";
        const isTargetDefault = cases[targetIndex].when === "default";
        
        // Don't allow moving default up or moving other cases down past default
        if (isMovingDefault && direction === 'up') return;
        if (isTargetDefault && direction === 'down') return;
        
        // Swap positions (including the entire case structure with do array)
        [cases[caseIndex], cases[targetIndex]] = [cases[targetIndex], cases[caseIndex]];
        
        // Refresh the properties panel and card display
        this.updatePropertiesPanel();
        this.refreshCard(cardId);
        
        console.log(`Moved case ${caseIndex} ${direction}:`, cardData);
    }
    
    // ===== çµ±ä¸€ Canvas æ›´æ–°ç³»çµ± =====
    // æ™ºèƒ½æ›´æ–°æ§åˆ¶å™¨ - æ‰€æœ‰æ›´æ–°éƒ½é€šéæ­¤æ¥å£
    updateCanvas(options = {}) {
        const defaults = {
            fullRefresh: false,      // æ˜¯å¦å®Œæ•´é‡å»º
            preserveScroll: true,    // ä¿ç•™æ²å‹•ä½ç½®
            skipDuringDrag: true,    // æ‹–æ›³æ™‚è·³é
            source: 'unknown'        // å‘¼å«ä¾†æºï¼ˆç”¨æ–¼é™¤éŒ¯ï¼‰
        };
        
        const config = { ...defaults, ...options };
        
        // æ‹–æ›³ä¸­æª¢æŸ¥
        const isDragging = this.isDragging();
        console.log(`ğŸ”„ updateCanvas called: source=${config.source}, skipDuringDrag=${config.skipDuringDrag}, isDragging=${isDragging}`);
        
        if (config.skipDuringDrag && isDragging) {
            console.log(`ğŸš« Skipping canvas update during drag (source: ${config.source})`);
            return;
        }
        
        console.log(`ğŸ”„ Canvas update proceeding (source: ${config.source}, full: ${config.fullRefresh})`);
        
        // ä¿å­˜æ²å‹•ä½ç½®
        const scrollState = config.preserveScroll ? this.saveScrollState() : null;
        
        // åŸ·è¡Œæ›´æ–°
        if (config.fullRefresh) {
            console.log('ğŸ”„ Performing full refresh');
            this.performFullRefresh();
        } else {
            console.log('ğŸ”„ Performing partial update');
            this.performPartialUpdate();
        }
        
        // æ¢å¾©æ²å‹•ä½ç½®
        if (scrollState) {
            this.restoreScrollState(scrollState);
        }
    }
    
    // æª¢æŸ¥æ˜¯å¦æ­£åœ¨æ‹–æ›³
    isDragging() {
        return this.draggedElement || 
               document.body.classList.contains('dragging');
    }
    
    // æª¢æŸ¥ç§»å‹•æ“ä½œæ˜¯å¦æ”¹è®Šäº†çµæ§‹ï¼ˆåµŒå¥— <-> å¤–å±¤ï¼‰
    checkIfStructureChanged(moveData) {
        if (!moveData || !moveData.cardId) return true; // å®‰å…¨èµ·è¦‹ï¼Œé è¨­å®Œæ•´æ›´æ–°
        
        // ä½¿ç”¨è¨˜éŒ„çš„åŸå§‹ä½ç½®
        const originalPos = this.cardOriginalPositions.get(moveData.cardId);
        const wasNested = originalPos ? originalPos.isNested : false;
        
        // æª¢æŸ¥æ–°ä½ç½®æ˜¯å¦åµŒå¥—
        const isNowNested = moveData.position && moveData.position.nested;
        
        // å¦‚æœå¾åµŒå¥—ç§»åˆ°å¤–å±¤æˆ–å¾å¤–å±¤ç§»åˆ°åµŒå¥—ï¼Œéœ€è¦å®Œæ•´æ›´æ–°
        if (wasNested && !isNowNested) {
            console.log('ğŸ“¤ Card moved from nested to top level - full refresh needed');
            return true;
        }
        if (!wasNested && isNowNested) {
            console.log('ğŸ“¦ Card moved from top level to nested - full refresh needed');
            return true;
        }
        
        // æª¢æŸ¥æ˜¯å¦åœ¨ä¸åŒçš„åµŒå¥—åˆ†æ”¯é–“ç§»å‹•ï¼ˆå¦‚ then -> elseï¼‰
        if (wasNested && isNowNested) {
            // éƒ½åœ¨åµŒå¥—ä¸­ï¼Œä½†å¯èƒ½åœ¨ä¸åŒåˆ†æ”¯
            // ç‚ºäº†å®‰å…¨èµ·è¦‹ï¼ŒåµŒå¥—é–“çš„ç§»å‹•éƒ½éœ€è¦å®Œæ•´æ›´æ–°
            console.log('ğŸ”„ Card moved between nested branches - full refresh needed');
            this.cardOriginalPositions.delete(moveData.cardId);
            return true;
        }
        
        // æ¸…ç†è¨˜éŒ„ï¼ˆæ‹–æ›³çµæŸï¼‰
        this.cardOriginalPositions.delete(moveData.cardId);
        
        // åªæœ‰é ‚å±¤ä¹‹é–“çš„ç§»å‹•æ‰æ˜¯éƒ¨åˆ†æ›´æ–°
        console.log('â†”ï¸ Card moved within top level - partial update sufficient');
        return false;
    }
    
    // ä¿å­˜æ²å‹•ç‹€æ…‹
    saveScrollState() {
        const container = document.querySelector('.tafl-canvas-container');
        if (!container) return null;
        return {
            scrollTop: container.scrollTop,
            scrollLeft: container.scrollLeft
        };
    }
    
    // æ¢å¾©æ²å‹•ç‹€æ…‹
    restoreScrollState(state) {
        if (!state) return;
        const container = document.querySelector('.tafl-canvas-container');
        if (container) {
            requestAnimationFrame(() => {
                container.scrollTop = state.scrollTop;
                container.scrollLeft = state.scrollLeft;
            });
        }
    }
    
    // éƒ¨åˆ†æ›´æ–°ï¼ˆåƒ…æ›´æ–°ä½ç½®ï¼Œé©ç”¨æ–¼æ‹–æ›³ï¼‰
    performPartialUpdate() {
        const dropZone = document.getElementById('canvas-drop-zone');
        if (!dropZone) return;
        
        console.log('âš¡ Performing partial update (order only)');
        
        // åªæ›´æ–°é ‚å±¤å¡ç‰‡çš„é †åºï¼Œä¸è™•ç†åµŒå¥—çµæ§‹è®ŠåŒ–
        const flow = taflFlowStore.getFlow();
        const cards = flow.flow || [];
        cards.forEach((card, index) => {
            const element = dropZone.querySelector(`:scope > [data-card-id="${card.id}"]`);
            if (element) {
                // ä½¿ç”¨ CSS order å±¬æ€§é‡æ–°æ’åºï¼Œé¿å… DOM é‡å»º
                element.style.order = index;
            }
        });
    }
    
    // å®Œæ•´é‡å»ºï¼ˆä¿ç•™åŸ refreshCanvas é‚è¼¯ï¼‰
    performFullRefresh() {
        this.refreshCanvasCore();
    }
    
    // èˆŠçš„ refreshCanvas ä¿ç•™ç‚ºå‘å¾Œç›¸å®¹
    refreshCanvas() {
        // ç›´æ¥èª¿ç”¨æ–°çš„çµ±ä¸€æ›´æ–°ç³»çµ±
        this.updateCanvas({ 
            fullRefresh: true, 
            source: 'legacy-refresh' 
        });
    }
    
    // åŸå§‹çš„ refreshCanvas é‚è¼¯ï¼ˆè¢« performFullRefresh ä½¿ç”¨ï¼‰
    refreshCanvasCore() {
        console.log('ğŸ¨ refreshCanvasCore() called');
        const canvas = document.getElementById('flow-canvas');
        if (!canvas) {
            console.error('ğŸ¨ Canvas element not found!');
            return;
        }
        
        const flow = taflFlowStore.getFlow();
        console.log('ğŸ¨ Current flow from store:', flow);
        console.log('ğŸ¨ Current flow.flow:', flow.flow, 'Length:', flow.flow ? flow.flow.length : 'undefined');
        console.log('ğŸ¨ Flow card IDs:', flow.flow ? flow.flow.map(c => c.id || 'no-id') : 'empty');
        
        // ä¿å­˜é¸ä¸­ç‹€æ…‹
        const selectedId = this.selectedCard?.dataset?.cardId;
        
        // æ¸…ç©ºç•«å¸ƒ
        console.log('ğŸ¨ Clearing canvas');
        canvas.innerHTML = '';
        
        if (flow.flow.length === 0) {
            console.log('ğŸ¨ Flow is empty, showing empty canvas UI');
            // é¡¯ç¤ºç©ºç™½æç¤º - èˆ‡ HTML æ¨¡æ¿ä¿æŒä¸€è‡´
            canvas.innerHTML = `
                <div class="canvas-drop-zone" id="canvas-drop-zone">
                    <div class="drop-zone-content">
                        <span class="icon is-large has-text-grey-light">
                            <i class="fas fa-grip-vertical fa-3x"></i>
                        </span>
                        <p class="has-text-grey">Drag TAFL verbs here to build your flow</p>
                        <p class="has-text-grey-light is-size-7">Or click on a verb from the toolbox</p>
                    </div>
                </div>
            `;
            // é‡æ–°è¨­ç½®ç©ºç•«å¸ƒçš„æ”¾ç½®å€
            this.createInitialDropZone();
        } else {
            // å‰µå»º drop zone å®¹å™¨
            const dropZone = document.createElement('div');
            dropZone.id = 'canvas-drop-zone';
            dropZone.className = 'canvas-drop-zone has-cards'; // åŠ ä¸Š has-cards class
            canvas.appendChild(dropZone);
            
            // æ¸²æŸ“æ‰€æœ‰å¡ç‰‡åˆ° drop zone å…§ï¼ˆä¸å†ç¶å®šå€‹åˆ¥äº‹ä»¶ï¼‰
            console.log('ğŸ¨ Rendering cards, flow.flow:', JSON.stringify(flow.flow, null, 2));
            flow.flow.forEach((cardData, index) => {
                console.log(`ğŸ¨ Creating card ${index}:`, cardData);
                const cardElement = this.createCardElementSimple(cardData);
                if (cardElement) {
                    console.log(`ğŸ¨ Card element created:`, cardElement);
                    dropZone.appendChild(cardElement);
                } else {
                    console.error(`ğŸ¨ Failed to create card element for index ${index}`);
                }
            });
        }
        
        // æ¢å¾©é¸ä¸­ç‹€æ…‹
        if (selectedId) {
            const card = document.querySelector(`[data-card-id="${selectedId}"]`);
            if (card) {
                this.selectCard(card);
            }
        }
        
        // Ensure all cards are draggable after refresh
        this.refreshCardDragHandlers();
    }
    
    // å·²è¢«å…¨åŸŸäº‹ä»¶å§”æ´¾å–ä»£ - cloneNode(true)æœƒç ´å£äº‹ä»¶å†’æ³¡ï¼
    setupNestedCardInteractions() {
        return; // ç›´æ¥è¿”å›ï¼Œä¸åŸ·è¡Œä»»ä½•æ“ä½œ
        // Set up click events for ALL nested cards (including deeply nested ones)
        // Use a more general selector that catches all nested cards at any depth
        document.querySelectorAll('.nested-cards .tafl-card').forEach(nestedCard => {
            // Skip if this is a direct child of flow-canvas (not actually nested)
            if (nestedCard.parentElement.id === 'flow-canvas') {
                return;
            }
            
            // Remove any existing click listeners to avoid duplicates
            const newCard = nestedCard.cloneNode(true);
            nestedCard.parentNode.replaceChild(newCard, nestedCard);
            
            // Add click listener that properly handles nested cards
            newCard.addEventListener('click', (e) => {
                // Prevent event from bubbling to parent cards
                e.stopPropagation();
                
                // Don't select if clicking on interactive elements
                if (e.target.closest('.card-controls') || 
                    e.target.closest('input') || 
                    e.target.closest('textarea') ||
                    e.target.closest('button')) {
                    return;
                }
                
                // Select this nested card
                this.selectCard(newCard);
            });
            
            // Note: Control buttons for nested cards are handled by event delegation
            // No need to bind individual events - they're handled in setupEventListeners()
            
            // Setup drag functionality for nested cards
            // è¨»ï¼šæ‹–æ”¾äº‹ä»¶å·²ç¶“ç”± setupGlobalEventDelegation çµ±ä¸€è™•ç†
            // é€™è£¡åªéœ€è¦ç¢ºä¿å¡ç‰‡æœ‰ draggable å±¬æ€§
            const dragHandle = newCard.querySelector('.card-drag-handle');
            if (dragHandle && !dragHandle.classList.contains('bound')) {
                dragHandle.classList.add('bound');
                newCard.draggable = true;
                // ä¸å†å–®ç¨ç¶å®š dragstart/dragend äº‹ä»¶
                // å…¨å±€äº‹ä»¶å§”æ´¾æœƒè™•ç†æ‰€æœ‰æ‹–æ”¾æ“ä½œ
            }
        });
        
        // All drop handling is done through unified drop handler
    }
    
    setupNestedDropTargets() {
        // Handle empty drop zones
        // Note: dragover and dragleave are now handled via event delegation in setupUnifiedDragDrop
        document.querySelectorAll('.nested-drop-zone.empty-zone').forEach(dropZone => {
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
                
                // Clear insertion lines when dropping
                this.hideDropIndicators();
                
                const dragData = this.getDragData(e) || this.dragData;
                if (!dragData) return;
                
                const nestedCards = dropZone.closest('.nested-cards');
                const parentCard = nestedCards?.closest('.tafl-card');
                const parentCardId = parentCard?.dataset.cardId;
                const branchType = dropZone.dataset.branch;
                
                if (parentCardId && branchType) {
                    if (dragData.type === 'verb') {
                        // Add new card to nested structure
                        const cardId = this.generateId();
                        // TAFL v1.1: verb as key, not property
                        const cardData = {
                            id: cardId,
                            [dragData.verb]: this.getDefaultParams(dragData.verb)[dragData.verb]
                        };
                        
                        this.addToNestedStructure(parentCardId, branchType, cardData);
                        this.updateCanvas({
                            fullRefresh: true,
                            source: 'nested:drag-add'
                        });
                        
                        // Select new card
                        const newElement = document.querySelector(`[data-card-id="${cardId}"]`);
                        if (newElement) {
                            newElement.classList.add('just-added');
                            setTimeout(() => newElement.classList.remove('just-added'), 500);
                            this.selectCard(newElement);
                        }
                        
                        this.markDirty();
                        this.showNotification(`Added ${dragData.verb} to ${branchType} branch`, 'is-success');
                    } else if (dragData.type === 'card') {
                        // Move existing card to nested structure
                        const cardData = this.findCardById(dragData.cardId);
                        if (cardData) {
                            this.removeCardFromFlow(dragData.cardId);
                            this.addToNestedStructure(parentCardId, branchType, cardData);
                            this.updateCanvas({
                                fullRefresh: true,
                                source: 'nested:drag-add-else'
                            });
                            
                            const movedElement = document.querySelector(`[data-card-id="${dragData.cardId}"]`);
                            if (movedElement) {
                                movedElement.classList.add('just-moved');
                                setTimeout(() => movedElement.classList.remove('just-moved'), 500);
                                this.selectCard(movedElement);
                            }
                            
                            this.markDirty();
                            this.showNotification(`Moved card to ${branchType} branch`, 'is-success');
                        }
                    }
                }
            });
        });
        
        // Set up horizontal drop indicators
        document.querySelectorAll('.drop-indicator.horizontal').forEach(indicator => {
            indicator.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Clear all other active indicators
                document.querySelectorAll('.drop-indicator.horizontal').forEach(ind => {
                    ind.classList.remove('active');
                });
                
                // Activate this indicator
                indicator.classList.add('active');
            });
            
            indicator.addEventListener('dragleave', (e) => {
                if (!indicator.contains(e.relatedTarget)) {
                    indicator.classList.remove('active');
                }
            });
            
            indicator.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                indicator.classList.remove('active');
                
                // Clear insertion lines when dropping
                this.hideDropIndicators();
                
                const dragData = this.getDragData(e) || this.dragData;
                if (!dragData) return;
                
                const nestedCards = indicator.closest('.nested-cards');
                const parentCard = nestedCards?.closest('.tafl-card');
                const parentCardId = parentCard?.dataset.cardId;
                const branchType = indicator.dataset.branch;
                const position = parseInt(indicator.dataset.position);
                
                if (parentCardId && branchType && !isNaN(position)) {
                    if (dragData.type === 'verb') {
                        // Add new card to nested structure at specific position
                        const cardId = this.generateId();
                        const cardData = {
                            id: cardId,
                            [dragData.verb]: this.getDefaultParams(dragData.verb)[dragData.verb]
                        };
                        
                        this.addToNestedStructureAtPosition(parentCardId, branchType, cardData, position);
                        this.updateCanvas({
                            fullRefresh: true,
                            source: 'nested:drag-position'
                        });
                        
                        // Select new card
                        const newElement = document.querySelector(`[data-card-id="${cardId}"]`);
                        if (newElement) {
                            newElement.classList.add('just-added');
                            setTimeout(() => newElement.classList.remove('just-added'), 500);
                            this.selectCard(newElement);
                        }
                        
                        this.markDirty();
                        this.showNotification(`Added ${dragData.verb} at position ${position + 1}`, 'is-success');
                    } else if (dragData.type === 'card') {
                        // Move existing card to specific position
                        const cardData = this.findCardById(dragData.cardId);
                        if (cardData) {
                            this.removeCardFromFlow(dragData.cardId);
                            this.addToNestedStructureAtPosition(parentCardId, branchType, cardData, position);
                            this.updateCanvas({
                                fullRefresh: true,
                                source: 'nested:drag-position-else'
                            });
                            
                            const movedElement = document.querySelector(`[data-card-id="${dragData.cardId}"]`);
                            if (movedElement) {
                                movedElement.classList.add('just-moved');
                                setTimeout(() => movedElement.classList.remove('just-moved'), 500);
                                this.selectCard(movedElement);
                            }
                            
                            this.markDirty();
                            this.showNotification(`Moved card to position ${position + 1}`, 'is-success');
                        }
                    }
                }
            });
        });
    }
    
    switchVerbCategory(category) {
        // Update active tab
        document.querySelectorAll('.panel-tabs a').forEach(tab => {
            tab.classList.toggle('is-active', tab.dataset.tab === category);
        });
        
        // Show/hide verb categories
        document.querySelectorAll('.verb-category').forEach(cat => {
            cat.style.display = 'none';
        });
        
        const targetCategory = document.getElementById(`${category}-verbs`);
        if (targetCategory) {
            targetCategory.style.display = 'block';
        }
    }
    
    switchPropertiesTab(tab) {
        // Update active tab
        document.querySelectorAll('.tabs li').forEach(tabEl => {
            tabEl.classList.toggle('is-active', tabEl.dataset.tab === tab);
        });
        
        // Show/hide panels
        document.querySelectorAll('.properties-content').forEach(panel => {
            panel.style.display = 'none';
        });
        
        const targetPanel = document.getElementById(`${tab}-panel`);
        if (targetPanel) {
            targetPanel.style.display = 'block';
        }
        
        // If switching to variables tab, update the panel
        if (tab === 'variables' && window.taflPanels) {
            window.taflPanels.updateVariablesPanel();
        }
        
        // Refresh CodeMirror editors for tabs that use JSON editors
        if (['preload', 'rules', 'variables'].includes(tab)) {
            // Small delay to ensure panel is visible before refreshing
            setTimeout(() => {
                if (window.taflPanels && window.taflPanels.refreshCodeMirrors) {
                    window.taflPanels.refreshCodeMirrors();
                }
            }, 50);
        }
        
        // Refresh YAML if switching to YAML tab
        if (tab === 'yaml') {
            this.yamlModule.refreshYAML();
        }
    }
    
    // newFlow() moved to tafl-editor-modals.js
    
    // OpenFlowModal removed - using dropdown selector instead
    // The dropdown in the header now handles flow selection
    
    // Delegate to flow module
    async openFlow(flowId) {
        return this.flowModule.openFlow(flowId);
    }
    
    /**
     * Recursively ensure all cards have IDs (including nested cards)
     */
    // Delegate to flow module
    ensureAllCardsHaveIds(cards) {
        return this.flowModule.ensureAllCardsHaveIds(cards);
    }
    
    // Delegate to flow module
    async loadFlow(flowDataOrId) {
        return this.flowModule.loadFlow(flowDataOrId);
    }
    
    // saveFlowModal() and saveFlow() moved to tafl-editor-modals.js
    
    
    // Delegate to flow module
    async executeFlow() {
        return this.flowModule.executeFlow();
    }
    
    
    // Note: rebuildCardsFromFlow has been removed - use updateCanvas instead
    // This function was redundant with refreshCanvas/refreshCanvasCore
    
    markDirty() {
        taflFlowStore.setDirty(true);
        this.notificationsModule.markDirty();
        this.notificationsModule.updateUI();
    }
    
    updateUI() {
        // Update metadata inputs
        document.getElementById('flow-id').value = taflFlowStore.getFlow().metadata.id || '';
        document.getElementById('flow-name').value = taflFlowStore.getFlow().metadata.name || '';
        document.getElementById('flow-version').value = taflFlowStore.getFlow().metadata.version || '1.0';
        document.getElementById('flow-description').value = taflFlowStore.getFlow().metadata.description || '';
        
        // Update save button state
        const saveBtn = document.getElementById('save-flow-btn');
        saveBtn.disabled = !taflFlowStore.isDirty() || taflFlowStore.getFlow().flow.length === 0;
        
        // Use notifications module for additional UI updates
        this.notificationsModule.updateUI();
        
        // Update title
        document.title = `TAFL Editor - ${taflFlowStore.getFlow().metadata.name}${taflFlowStore.isDirty() ? ' *' : ''}`;
    }
    
    showNotification(message, type = 'is-info') {
        // Delegate to notifications module
        this.notificationsModule.showNotification(message, type);
    }
    
    /**
     * ç•¶æµç¨‹æ”¹è®Šæ™‚èª¿ç”¨ï¼ˆä¾›æ‹–æ”¾ç³»çµ±ä½¿ç”¨ï¼‰
     */
    onFlowChanged() {
        console.log('Flow structure changed');
        
        // æ›´æ–° store ä¸­çš„æµç¨‹è³‡æ–™
        if (this.store) {
            const flowData = this.exportFlowFromCanvas();
            this.store.updateFlow(flowData);
        }
        
        // è§¸ç™¼ä»»ä½•éœ€è¦çš„æ›´æ–°
        // ä¾‹å¦‚ï¼šæ›´æ–° YAML è¦–åœ–ã€ä¿å­˜è‰ç¨¿ç­‰
    }
}

// Export the TAFLEditor class
export { TAFLEditor };

// Initialize TAFL Editor when page loads
document.addEventListener('DOMContentLoaded', async () => {
    // Don't clear localStorage on every page load - let the store manage persistence
    // localStorage.removeItem('taflEditor');
    
    const taflEditor = new TAFLEditor();
    
    // Setup event delegation for flow dropdown items
    const dropdownContent = document.getElementById('flows-dropdown-content');
    if (dropdownContent) {
        dropdownContent.addEventListener('click', async function(e) {
            const flowItem = e.target.closest('.flow-dropdown-item');
            if (flowItem) {
                const flowId = flowItem.dataset.flowId;
                if (flowId) {
                    try {
                        const flowData = await taflAPI.getFlow(flowId);
                        taflEditor.loadFlow(flowData);
                        
                        // Show success notification using the notification module
                        const flowName = flowData.flow?.metadata?.name || flowData.flow?.name || flowId;
                        taflEditor.notificationsModule.success(`Flow "${flowName}" loaded successfully`);
                        
                        // Save as last edited flow
                        localStorage.setItem('lastEditedFlowId', flowId);
                        // Close dropdown
                        const dropdown = flowItem.closest('.navbar-dropdown');
                        if (dropdown) {
                            dropdown.parentElement.classList.remove('is-active');
                        }
                    } catch (error) {
                        console.error('Failed to load flow:', error);
                        taflEditor.notificationsModule.error('Failed to load flow: ' + error.message);
                    }
                }
            }
        });
    }
    
    // Load flows dropdown using module method
    await taflEditor.flowModule.loadFlowsDropdown();
    
    // Make loadFlowsDropdown available globally for modals module
    window.loadFlowsDropdown = () => taflEditor.flowModule.loadFlowsDropdown();
    
    // ä¸è¦è‡ªå‹•è¼‰å…¥ localStorage ä¸­çš„ flow
    // ä½¿ç”¨è€…éœ€è¦æ‰‹å‹•é¸æ“‡è¦è¼‰å…¥çš„ flow
    console.log('TAFL Editor initialized. Please select a flow from the dropdown or create a new one.');
});

// Global functions have been moved to module methods:
// - loadFirstAvailableFlow -> taflEditor.flowModule.loadFirstAvailableFlow()
// - loadFlowsDropdown -> taflEditor.flowModule.loadFlowsDropdown()
// - loadFlow is handled inline in the event handler or via taflEditor.loadFlow()