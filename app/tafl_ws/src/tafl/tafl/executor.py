"""
TAFL Executor Implementation
執行 TAFL 抽象語法樹

This module implements the runtime execution engine for TAFL programs.
It executes the AST generated by the parser and integrates with the
existing Flow WCS function system.
"""

import asyncio
import logging
from typing import Any, Dict, List, Optional, Union
from datetime import datetime
from .ast_nodes import *

# Optional: Import flow_function if available (for Flow WCS integration)
try:
    from flow_wcs.decorators import flow_function
except ImportError:
    # If not in Flow WCS environment, create a dummy decorator
    def flow_function(name=None, description=None, params=None, returns=None):
        def decorator(func):
            return func
        return decorator


class TAFLRuntimeError(Exception):
    """TAFL runtime execution error / TAFL 運行時錯誤"""
    pass


class TAFLExecutionContext:
    """
    Execution context for TAFL programs
    TAFL 程序執行上下文
    """
    
    def __init__(self, initial_variables: Optional[Dict[str, Any]] = None):
        # TAFL v1.1: 5-level variable scoping
        self.rules_scope = {}        # Rules scope (global, read-only)
        self.preload_scope = {}      # Preload scope (global, cached)
        self.global_scope = initial_variables or {}  # Global scope
        self.flow_scope = {}         # Flow scope
        self.loop_scope = {}         # Loop scope (current loop variables)
        
        # Legacy variables for backward compatibility
        self.variables = initial_variables or {}
        
        self.stack = []  # Variable scope stack for nested contexts
        self.logger = logging.getLogger('tafl.executor')
        self.stopped = False
        self.stop_reason = None
        
        # Function registry - will be populated from flow_executor functions
        self.functions = {}
        self._load_builtin_functions()
    
    def _load_builtin_functions(self):
        """Load built-in TAFL functions / 載入內建 TAFL 函數"""
        # Math functions
        self.functions['min'] = min
        self.functions['max'] = max
        self.functions['sum'] = sum
        self.functions['len'] = len
        self.functions['round'] = round
        self.functions['abs'] = abs
        
        # String functions
        self.functions['upper'] = str.upper
        self.functions['lower'] = str.lower
        self.functions['strip'] = str.strip
        
        # Type conversion
        self.functions['int'] = int
        self.functions['float'] = float
        self.functions['str'] = str
        self.functions['bool'] = bool
        
        # Date/time
        self.functions['now'] = datetime.now
        self.functions['today'] = datetime.today
    
    def push_scope(self):
        """Push a new variable scope / 推入新的變數作用域"""
        self.stack.append(self.variables.copy())
    
    def pop_scope(self):
        """Pop variable scope / 彈出變數作用域"""
        if self.stack:
            self.variables = self.stack.pop()
    
    def get_variable(self, name: str, path: List[str] = None) -> Any:
        """Get variable value with optional path / 獲取變數值（支持路徑）"""
        # TAFL v1.1: 5-level variable resolution order
        # 1. Loop scope (highest priority)
        if name in self.loop_scope:
            value = self.loop_scope[name]
        # 2. Flow scope
        elif name in self.flow_scope:
            value = self.flow_scope[name]
        # 3. Global scope
        elif name in self.global_scope:
            value = self.global_scope[name]
        # 4. Preload scope
        elif name in self.preload_scope:
            value = self.preload_scope[name]
        # 5. Rules scope (with 'rules.' prefix)
        elif name == 'rules':
            value = self.rules_scope
        elif name.startswith('rules.') and len(name) > 6:
            rule_name = name[6:]  # Remove 'rules.' prefix
            if rule_name in self.rules_scope:
                rule = self.rules_scope[rule_name]
                value = rule.value if rule.condition is None else rule.condition
            else:
                value = None
        # Legacy: Check old variables dict for backward compatibility
        else:
            value = self.variables.get(name)
        
        if value is None:
            return None
        
        # Navigate nested path
        if path:
            for key in path:
                if isinstance(value, dict):
                    value = value.get(key)
                elif isinstance(value, list) and key.isdigit():
                    idx = int(key)
                    value = value[idx] if 0 <= idx < len(value) else None
                else:
                    return None
                
                if value is None:
                    break
        
        return value
    
    def set_variable(self, name: str, value: Any, scope: str = 'flow'):
        """Set variable value / 設置變數值"""
        # Set in appropriate scope
        if scope == 'rules':
            # Rules are read-only, ignore set attempts
            self.logger.warning(f"Attempt to modify read-only rules variable: {name}")
            return
        elif scope == 'preload':
            self.preload_scope[name] = value
        elif scope == 'global':
            self.global_scope[name] = value
        elif scope == 'loop':
            self.loop_scope[name] = value
        else:  # 'flow' or default
            self.flow_scope[name] = value
        
        # Also set in legacy variables for backward compatibility
        self.variables[name] = value
    
    def call_function(self, name: str, args: List[Any]) -> Any:
        """Call a function / 調用函數"""
        if name not in self.functions:
            raise TAFLRuntimeError(f"Unknown function: {name}")
        
        func = self.functions[name]
        try:
            return func(*args)
        except Exception as e:
            raise TAFLRuntimeError(f"Function {name} failed: {e}")


class TAFLExecutor:
    """
    TAFL Program Executor
    TAFL 程序執行器
    """
    
    def __init__(self, function_registry: Optional[Dict[str, Any]] = None):
        self.logger = logging.getLogger('tafl.executor')
        self.function_registry = function_registry or {}
        self.context = None
    
    def _interpolate_string(self, text: str) -> str:
        """Interpolate variables in string / 在字符串中插值變數"""
        import re
        
        def replace_var(match):
            var_expr = match.group(1)
            
            # Handle nested property access (e.g., location.name)
            if '.' in var_expr:
                parts = var_expr.split('.')
                var_name = parts[0]
                path = parts[1:]
                value = self.context.get_variable(var_name, path)
            else:
                value = self.context.get_variable(var_expr)
            
            return str(value) if value is not None else f'${{{var_expr}}}'
        
        # Find and replace all ${...} patterns
        pattern = r'\$\{([^}]+)\}'
        return re.sub(pattern, replace_var, text)
    
    async def execute(self, program: TAFLProgram, 
                      initial_context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute a TAFL program
        執行 TAFL 程序
        
        Args:
            program: The parsed TAFL program AST
            initial_context: Initial variable context
            
        Returns:
            Final execution context with all variables
        """
        # Initialize execution context
        all_vars = program.variables.copy()
        if initial_context:
            all_vars.update(initial_context)
        
        self.context = TAFLExecutionContext(all_vars)
        
        # Add external functions to context
        self.context.functions.update(self.function_registry)
        
        self.logger.info(f"Starting execution of flow: {program.metadata.id}")
        
        try:
            # TAFL v1.1: 4-phase execution model
            
            # Phase 1: Preload Phase - Execute all queries and cache results
            await self._execute_preload_phase(program.preload)
            
            # Phase 2: Rules Evaluation - Process and cache business rules
            await self._execute_rules_phase(program.rules)
            
            # Phase 3: Variable Initialization - Initialize variables from variables section
            await self._execute_variables_phase(program.variables)
            
            # Phase 4: Flow Execution - Execute statements using preloaded data and rules
            await self._execute_flow_phase(program.flow)
            
            self.logger.info(f"Flow execution completed: {program.metadata.id}")
            
        except Exception as e:
            self.logger.error(f"Flow execution failed: {e}")
            raise TAFLRuntimeError(f"Execution failed: {e}")
        
        return self.context.variables
    
    async def _execute_preload_phase(self, preload_statements: List[PreloadStatement]):
        """Execute preload phase - cache data for performance"""
        self.logger.info("Phase 1: Executing preload phase")
        
        for stmt in preload_statements:
            self.logger.debug(f"Preloading: {stmt.target} -> {stmt.store_as}")
            
            # Execute preload query
            result = await self._execute_preload_query(stmt)
            
            # Store in preload scope
            if stmt.store_as:
                self.context.preload_scope[stmt.store_as] = result
                # Also store in legacy variables for compatibility
                self.context.variables[stmt.store_as] = result
    
    async def _execute_rules_phase(self, rules: Dict[str, RuleDefinition]):
        """Execute rules phase - process and cache business rules"""
        self.logger.info("Phase 2: Processing rules phase")
        
        # Store rules in rules scope
        self.context.rules_scope = rules
        
        # Create rules object for easy access
        rules_object = {}
        for rule_name, rule in rules.items():
            if rule.condition is None:
                # Configuration value rule
                rules_object[rule_name] = rule.value
            else:
                # Condition rule - store the rule itself for later evaluation
                rules_object[rule_name] = rule
        
        # Store rules object in preload scope for ${rules.xxx} access
        self.context.preload_scope['rules'] = rules_object
        self.context.variables['rules'] = rules_object
    
    async def _execute_variables_phase(self, variables: Dict[str, Any]):
        """Execute variables phase - initialize variables"""
        self.logger.info("Phase 3: Initializing variables phase")
        
        for var_name, var_value in variables.items():
            self.context.set_variable(var_name, var_value, scope='global')
    
    async def _execute_flow_phase(self, flow_statements: List[Statement]):
        """Execute flow phase - main execution logic"""
        self.logger.info("Phase 4: Executing flow phase")
        
        for statement in flow_statements:
            if self.context.stopped:
                self.logger.info(f"Flow stopped: {self.context.stop_reason}")
                break
            
            await self._execute_statement(statement)
    
    async def _execute_preload_query(self, stmt: PreloadStatement) -> Any:
        """Execute a preload query statement"""
        self.logger.debug(f"Preload query: {stmt.target}")
        
        # Map to existing query functions
        func_name = f"query_{stmt.target}"
        if func_name not in self.context.functions:
            # Try generic query function
            func_name = "query"
        
        if func_name in self.context.functions:
            # Prepare query parameters
            params = {'target': stmt.target}
            if stmt.filters:
                for key, expr in stmt.filters.items():
                    params[key] = await self._evaluate_expression(expr)
            
            if stmt.limit:
                params['limit'] = stmt.limit
            
            # Execute query
            result = await self._call_async_function(func_name, params)
            return result
        else:
            raise TAFLRuntimeError(f"Preload query function not found for: {stmt.target}")
    
    async def _execute_statement(self, stmt: Statement) -> Any:
        """Execute a single statement / 執行單個語句"""
        if stmt.comment:
            self.logger.debug(f"Executing: {stmt.comment}")
        
        if isinstance(stmt, QueryStatement):
            return await self._execute_query(stmt)
        elif isinstance(stmt, CheckStatement):
            return await self._execute_check(stmt)
        elif isinstance(stmt, CreateStatement):
            return await self._execute_create(stmt)
        elif isinstance(stmt, UpdateStatement):
            return await self._execute_update(stmt)
        elif isinstance(stmt, IfStatement):
            return await self._execute_if(stmt)
        elif isinstance(stmt, ForStatement):
            return await self._execute_for(stmt)
        elif isinstance(stmt, SwitchStatement):
            return await self._execute_switch(stmt)
        elif isinstance(stmt, SetStatement):
            return await self._execute_set(stmt)
        elif isinstance(stmt, StopStatement):
            return await self._execute_stop(stmt)
        elif isinstance(stmt, NotifyStatement):
            return await self._execute_notify(stmt)
        else:
            raise TAFLRuntimeError(f"Unknown statement type: {type(stmt)}")
    
    async def _execute_query(self, stmt: QueryStatement) -> Any:
        """Execute query statement / 執行查詢語句"""
        self.logger.debug(f"Query: {stmt.target}")
        
        # Map to existing query functions
        func_name = f"query_{stmt.target}"
        if func_name not in self.context.functions:
            # Try generic query function
            func_name = "query"
        
        if func_name in self.context.functions:
            # Prepare query parameters
            params = {'target': stmt.target}
            if stmt.filters:
                for key, expr in stmt.filters.items():
                    params[key] = await self._evaluate_expression(expr)
            
            # Execute query
            result = await self._call_async_function(func_name, params)
            
            # Store result if needed
            if stmt.store_as:
                self.context.set_variable(stmt.store_as, result)
            
            return result
        else:
            raise TAFLRuntimeError(f"Query function not found for: {stmt.target}")
    
    async def _execute_check(self, stmt: CheckStatement) -> bool:
        """Execute check statement / 執行檢查語句"""
        result = await self._evaluate_expression(stmt.condition)
        
        if stmt.store_as:
            self.context.set_variable(stmt.store_as, result)
        
        self.logger.debug(f"Check result: {result}")
        return result
    
    async def _execute_create(self, stmt: CreateStatement) -> Any:
        """Execute create statement / 執行創建語句"""
        self.logger.debug(f"Create: {stmt.target}")
        
        # Map to existing create functions
        func_name = f"create_{stmt.target}"
        if func_name not in self.context.functions:
            func_name = "create"
        
        if func_name in self.context.functions:
            # Evaluate parameters
            params = {'target': stmt.target}
            for key, expr in stmt.parameters.items():
                params[key] = await self._evaluate_expression(expr)
            
            # Execute creation
            result = await self._call_async_function(func_name, params)
            
            # Store result if needed
            if stmt.store_as:
                self.context.set_variable(stmt.store_as, result)
            
            return result
        else:
            raise TAFLRuntimeError(f"Create function not found for: {stmt.target}")
    
    async def _execute_update(self, stmt: UpdateStatement) -> Any:
        """Execute update statement / 執行更新語句"""
        self.logger.debug(f"Update: {stmt.target}")
        
        # Get ID
        id_value = await self._evaluate_expression(stmt.id_expr)
        
        # Evaluate changes
        changes = {}
        for key, expr in stmt.changes.items():
            changes[key] = await self._evaluate_expression(expr)
        
        # Map to update function
        func_name = f"update_{stmt.target}"
        if func_name not in self.context.functions:
            func_name = "update"
        
        if func_name in self.context.functions:
            params = {
                'target': stmt.target,
                'id': id_value,
                'changes': changes
            }
            return await self._call_async_function(func_name, params)
        else:
            raise TAFLRuntimeError(f"Update function not found for: {stmt.target}")
    
    async def _execute_if(self, stmt: IfStatement) -> Any:
        """Execute if statement / 執行條件語句"""
        condition = await self._evaluate_expression(stmt.condition)
        
        if condition:
            for s in stmt.then_branch:
                await self._execute_statement(s)
        elif stmt.else_branch:
            for s in stmt.else_branch:
                await self._execute_statement(s)
    
    async def _execute_for(self, stmt: ForStatement) -> Any:
        """Execute for loop / 執行循環語句"""
        iterable = await self._evaluate_expression(stmt.iterable)
        
        if not isinstance(iterable, (list, tuple, set)):
            raise TAFLRuntimeError(f"Cannot iterate over {type(iterable)}")
        
        # Save loop scope to restore later
        saved_loop_scope = self.context.loop_scope.copy()
        
        try:
            for item in iterable:
                # Set loop variable in loop scope
                self.context.loop_scope[stmt.variable] = item
                
                # Apply filter condition if specified (new in v1.1)
                if stmt.filter:
                    filter_result = await self._evaluate_expression(stmt.filter)
                    if not filter_result:
                        continue  # Skip this item
                
                # Execute loop body
                for s in stmt.body:
                    if self.context.stopped:
                        break
                    await self._execute_statement(s)
                
                if self.context.stopped:
                    break
        finally:
            # Restore loop scope
            self.context.loop_scope = saved_loop_scope
    
    async def _execute_switch(self, stmt: SwitchStatement) -> Any:
        """Execute switch statement / 執行分支語句"""
        value = await self._evaluate_expression(stmt.expression)
        
        executed = False
        for case in stmt.cases:
            case_value = await self._evaluate_expression(case.value)
            # Debug logging
            self.logger.debug(f"Comparing switch value {value} (type: {type(value)}) with case {case_value} (type: {type(case_value)})")
            
            # Type-aware comparison
            if type(value) == type(case_value) and value == case_value:
                for s in case.body:
                    await self._execute_statement(s)
                executed = True
                break
            # Try converting to same type for comparison
            elif str(value) == str(case_value):
                for s in case.body:
                    await self._execute_statement(s)
                executed = True
                break
        
        if not executed and stmt.default:
            for s in stmt.default:
                await self._execute_statement(s)
    
    async def _execute_set(self, stmt: SetStatement) -> Any:
        """Execute set statement / 執行設置語句"""
        value = await self._evaluate_expression(stmt.value)
        self.context.set_variable(stmt.variable, value, scope='flow')
        self.logger.debug(f"Set {stmt.variable} = {value}")
    
    async def _execute_stop(self, stmt: StopStatement) -> Any:
        """Execute stop statement / 執行停止語句"""
        if stmt.condition:
            should_stop = await self._evaluate_expression(stmt.condition)
            if not should_stop:
                return
        
        self.context.stopped = True
        self.context.stop_reason = stmt.reason or "Flow stopped"
        self.logger.info(f"Stop flow: {self.context.stop_reason}")
    
    async def _execute_notify(self, stmt: NotifyStatement) -> Any:
        """Execute notify statement / 執行通知語句"""
        message = await self._evaluate_expression(stmt.message)
        
        # Log the notification
        level = stmt.level or 'info'
        log_func = getattr(self.logger, level, self.logger.info)
        log_func(f"[{stmt.channel}] {message}")
        
        # Call notification function if available
        func_name = f"notify_{stmt.channel}"
        if func_name in self.context.functions:
            params = {
                'message': message,
                'level': level
            }
            if stmt.metadata:
                for key, expr in stmt.metadata.items():
                    params[key] = await self._evaluate_expression(expr)
            
            return await self._call_async_function(func_name, params)
        
        # Try generic notify function
        elif 'notify' in self.context.functions:
            params = {
                'channel': stmt.channel,
                'message': message,
                'level': level
            }
            if stmt.metadata:
                for key, expr in stmt.metadata.items():
                    params[key] = await self._evaluate_expression(expr)
            
            return await self._call_async_function('notify', params)
    
    async def _evaluate_expression(self, expr: Expression) -> Any:
        """Evaluate an expression / 求值表達式"""
        if isinstance(expr, Literal):
            # Handle string interpolation for string literals
            if expr.type == 'string' and isinstance(expr.value, str):
                interpolated = self._interpolate_string(expr.value)
                # Try to evaluate as mathematical expression
                try:
                    # Check if it looks like a math expression
                    if any(op in interpolated for op in ['+', '-', '*', '/']):
                        # Safely evaluate mathematical expression
                        return eval(interpolated)
                except:
                    pass
                return interpolated
            return expr.value
        
        elif isinstance(expr, Variable):
            value = self.context.get_variable(expr.name, expr.path)
            
            # Special handling for rules references
            if expr.name == 'rules' and expr.path:
                rule_name = expr.path[0]
                if rule_name in self.context.rules_scope:
                    rule = self.context.rules_scope[rule_name]
                    if rule.condition is not None:
                        # Evaluate rule condition
                        return await self._evaluate_expression(rule.condition)
                    else:
                        # Return configuration value
                        if len(expr.path) > 1:
                            # Navigate deeper into the configuration object
                            config_value = rule.value
                            for key in expr.path[1:]:
                                if isinstance(config_value, dict):
                                    config_value = config_value.get(key)
                                else:
                                    return None
                            return config_value
                        else:
                            return rule.value
            
            return value
        
        elif isinstance(expr, BinaryOp):
            left = await self._evaluate_expression(expr.left)
            right = await self._evaluate_expression(expr.right)
            
            if expr.operator == '+':
                return left + right
            elif expr.operator == '-':
                return left - right
            elif expr.operator == '*':
                return left * right
            elif expr.operator == '/':
                return left / right if right != 0 else None
            elif expr.operator == '==':
                return left == right
            elif expr.operator == '!=':
                return left != right
            elif expr.operator == '<':
                return left < right
            elif expr.operator == '>':
                return left > right
            elif expr.operator == '<=':
                return left <= right
            elif expr.operator == '>=':
                return left >= right
            elif expr.operator == 'and':
                return left and right
            elif expr.operator == 'or':
                return left or right
            else:
                raise TAFLRuntimeError(f"Unknown operator: {expr.operator}")
        
        elif isinstance(expr, UnaryOp):
            operand = await self._evaluate_expression(expr.operand)
            
            if expr.operator == 'not':
                return not operand
            elif expr.operator == '-':
                return -operand
            else:
                raise TAFLRuntimeError(f"Unknown unary operator: {expr.operator}")
        
        elif isinstance(expr, FunctionCall):
            args = []
            for arg_expr in expr.arguments:
                args.append(await self._evaluate_expression(arg_expr))
            return self.context.call_function(expr.name, args)
        
        elif isinstance(expr, ArrayExpression):
            result = []
            for elem in expr.elements:
                result.append(await self._evaluate_expression(elem))
            return result
        
        elif isinstance(expr, DictExpression):
            result = {}
            for key, value_expr in expr.pairs:
                result[key] = await self._evaluate_expression(value_expr)
            return result
        
        else:
            raise TAFLRuntimeError(f"Unknown expression type: {type(expr)}")
    
    async def _call_async_function(self, name: str, params: Dict[str, Any]) -> Any:
        """Call an async function from the registry / 調用異步函數"""
        if name not in self.context.functions:
            raise TAFLRuntimeError(f"Function not found: {name}")
        
        func = self.context.functions[name]
        
        # Check if function is async
        if asyncio.iscoroutinefunction(func):
            return await func(**params)
        else:
            return func(**params)